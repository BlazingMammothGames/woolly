{
"version":3,
"file":"game.js",
"sourceRoot":"file:///",
"sources":["/usr/share/haxe/std/js/_std/EReg.hx","/usr/share/haxe/std/js/_std/HxOverrides.hx","/usr/share/haxe/std/List.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/Main.hx","/usr/share/haxe/std/js/_std/Std.hx","/usr/share/haxe/std/StringTools.hx","/usr/share/haxe/std/js/_std/Type.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/components/Spin.hx","/home/kenton/.haxe/edge/git/src/edge/Engine.hx","/home/kenton/.haxe/edge/git/src/edge/Entity.hx","/home/kenton/.haxe/edge/git/src/edge/Phase.hx","/home/kenton/.haxe/edge/git/src/edge/View.hx","/home/kenton/.haxe/edge/git/src/edge/core/NodeSystem.hx","/home/kenton/.haxe/edge/git/src/edge/core/NodeSystemIterator.hx","/usr/share/haxe/std/haxe/CallStack.hx","/usr/share/haxe/std/haxe/Int64.hx","/usr/share/haxe/std/js/_std/haxe/io/Bytes.hx","/usr/share/haxe/std/haxe/crypto/Base64.hx","/usr/share/haxe/std/haxe/crypto/BaseCode.hx","/usr/share/haxe/std/js/_std/haxe/ds/IntMap.hx","/usr/share/haxe/std/js/_std/haxe/ds/ObjectMap.hx","/usr/share/haxe/std/js/_std/haxe/ds/StringMap.hx","/usr/share/haxe/std/haxe/io/FPHelper.hx","/usr/share/haxe/std/js/_std/haxe/io/Float32Array.hx","/usr/share/haxe/std/js/_std/haxe/io/Int32Array.hx","/usr/share/haxe/std/js/Boot.hx","/usr/share/haxe/std/js/html/CanvasElement.hx","/usr/share/haxe/std/js/html/compat/ArrayBuffer.hx","/usr/share/haxe/std/js/html/compat/DataView.hx","/usr/share/haxe/std/js/html/compat/Float32Array.hx","/usr/share/haxe/std/js/html/compat/Uint8Array.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/Log.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/platform/js/Assets.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/gl/js/Graphics.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/platform/js/Input.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/Resources.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/Stats.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/platform/js/Timing.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/Mammoth.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/tusk/Control.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/components/Camera.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/components/DirectionalLight.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/components/MeshRenderer.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/components/PointLight.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/components/Transform.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/debug/DebugView.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/debug/Exception.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/defaults/Materials.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/macros/FileContents.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/filetypes/MammothJSON.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/systems/CameraSystem.hx","/home/kenton/.haxe/edge/git/src/edge/core/macro/BuildSystem.hx","/home/kenton/.haxe/edge/git/src/edge/core/macro/Macros.hx","/home/kenton/.haxe/edge/git/src/edge/core/macro/BuildSystemProcess.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/systems/DirectionalLightSystem.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/systems/DirectionalShadowSystem.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/systems/ModelMatrixSystem.hx","/home/kenton/Projects/blazingmammothgames/haxe-glm/src/glm/Quat.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/systems/PreTransformSystem.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/systems/RenderSystem.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/types/Material.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/types/MaterialAttribute.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/types/Mesh.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/types/MeshAttribute.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/types/ShaderUniform.hx","/home/kenton/.haxe/promhx/1,1,0/src/main/promhx/base/AsyncBase.hx","/home/kenton/.haxe/promhx/1,1,0/src/main/promhx/Deferred.hx","/home/kenton/.haxe/promhx/1,1,0/src/main/promhx/Promise.hx","/home/kenton/.haxe/promhx/1,1,0/src/main/promhx/base/EventLoop.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/systems/SpinSystem.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/tusk/Draw.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/tusk/text/Font.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/tusk/text/Glyph.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/tusk/Tusk.hx","/home/kenton/Projects/blazingmammothgames/haxe-glm/src/glm/GLM.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/mammoth/defaults/Colours.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/tusk/macros/FileContents.hx","/home/kenton/Projects/blazingmammothgames/woolly/src/tusk/TuskConfig.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : HaxeRegExp;\n\n\tpublic inline function new( r : String, opt : String ) : Void {\n\t\tthis.r = new HaxeRegExp(r, opt.split(\"u\").join(\"\")); // 'u' (utf8) depends on page encoding\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic inline function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n\n@:native(\"RegExp\")\nprivate extern class HaxeRegExp extends js.RegExp {\n\tvar m:js.RegExp.RegExpMatch;\n\tvar s:String;\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\tvar x = (cast s).charCodeAt(index);\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn js.Lib.undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif (len == null) {\n\t\t\tlen = s.length;\n\t\t} else if (len < 0) {\n\t\t\tif (pos == 0)\n\t\t\t\tlen = s.length + len;\n\t\t\telse\n\t\t\t\treturn \"\";\n\t\t}\n\n\t\t#if (js_es < 5)\n\t\tif (pos < 0) {\n\t\t\tpos = s.length + pos;\n\t\t\tif (pos < 0)\n\t\t\t\tpos = 0;\n\t\t}\n\t\t#end\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if (js_es < 5)\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tA linked-list of elements. The list is composed of element container objects\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole list content every time.\n\n\t@see https://haxe.org/manual/std-List.html\n**/\nclass List<T> {\n\n\tprivate var h : ListNode<T>;\n\tprivate var q : ListNode<T>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default,null) : Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add( item : T ) {\n\t\tvar x = ListNode.create(item, null);\n\t\tif( h == null )\n\t\t\th = x;\n\t\telse\n\t\t\tq.next = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push( item : T ) {\n\t\tvar x = ListNode.create(item, h);\n\t\th = x;\n\t\tif( q == null )\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first() : Null<T> {\n\t\treturn if( h == null ) null else h.item;\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last() : Null<T> {\n\t\treturn if( q == null ) null else q.item;\n\t}\n\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop() : Null<T> {\n\t\tif( h == null )\n\t\t\treturn null;\n\t\tvar x = h.item;\n\t\th = h.next;\n\t\tif( h == null )\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty() : Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear() : Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurrence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove( v : T ) : Bool {\n\t\tvar prev:ListNode<T> = null;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( l.item == v ) {\n\t\t\t\tif( prev == null )\n\t\t\t\t\th = l.next;\n\t\t\t\telse\n\t\t\t\t\tprev.next = l.next;\n\t\t\t\tif( q == l )\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l.next;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic inline function iterator() : ListIterator<T> {\n\t\treturn new ListIterator<T>(h);\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l.item));\n\t\t\tl = l.next;\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep : String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l.item);\n\t\t\tl = l.next;\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter( f : T -> Bool ) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l.item;\n\t\t\tl = l.next;\n\t\t\tif( f(v) )\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f : T -> X) : List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l.item;\n\t\t\tl = l.next;\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n\n}\n\n#if neko\nprivate extern class ListNode<T> extends neko.NativeArray<Dynamic> {\n\tvar item(get,set):T;\n\tvar next(get,set):ListNode<T>;\n\tprivate inline function get_item():T return this[0];\n\tprivate inline function set_item(v:T):T return this[0] = v;\n\tprivate inline function get_next():ListNode<T> return this[1];\n\tprivate inline function set_next(v:ListNode<T>):ListNode<T> return this[1] = v;\n\tinline static function create<T>(item:T, next:ListNode<T>):ListNode<T> {\n\t\treturn untyped __dollar__array(item, next);\n\t}\n}\n#else\nprivate class ListNode<T> {\n\tpublic var item:T;\n\tpublic var next:ListNode<T>;\n\tpublic function new(item:T, next:ListNode<T>) {\n\t\tthis.item = item;\n\t\tthis.next = next;\n\t}\n\t@:extern public inline static function create<T>(item:T, next:ListNode<T>):ListNode<T> {\n\t\treturn new ListNode(item, next);\n\t}\n}\n#end\n\nprivate class ListIterator<T> {\n\tvar head:ListNode<T>;\n\n\tpublic inline function new(head:ListNode<T>) {\n\t\tthis.head = head;\n\t}\n\n\tpublic inline function hasNext():Bool {\n\t\treturn head != null;\n\t}\n\n\tpublic inline function next():T {\n\t\tvar val = head.item;\n\t\thead = head.next;\n\t\treturn val;\n\t}\n}\n","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage;\n\nimport mammoth.Mammoth;\nimport mammoth.AssetList;\nimport mammoth.Log;\n\nclass Main {\n    public static function main() {\n        Mammoth.init(onReady);\n    }\n\n    private static function onReady():Void {\n        Log.info(\"Loading...\");\n        Mammoth.assets.loadJSON(AssetList.asset___iso__json)\n            .then(function(data:Dynamic) {\n                mammoth.filetypes.MammothJSON.load(data);\n                Log.info(\"Done!\");\n\n                // print all the objects\n                for(entity in Mammoth.engine.entities()) {\n                    var t:mammoth.components.Transform = entity.get(mammoth.components.Transform);\n                    if(t != null) {\n                        if(t.name == 'Cube') {\n                            mammoth.Log.info('Adding spin to \"Cube\"!');\n                            var spin:components.Spin = new components.Spin();\n                            spin.angle = 0;\n                            spin.speed = Math.PI / 10;\n                            entity.add(spin);\n                        }\n                    }\n                }\n\n                Mammoth.updatePhase.add(new systems.SpinSystem());\n\n                Mammoth.begin();\n            })\n            .catchError(function(e:Dynamic) {\n                Log.error(e);\n            });\n        Mammoth.begin();\n    }\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\t@:pure\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn (cast x) | 0;\n\t}\n\n\t@:pure\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static inline function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if (js_es < 5)\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)\n\tto the `String` class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cpp\nusing cpp.NativeString;\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua) inline #end public static function urlEncode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"encodeURIComponent\"](s);\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLEncode();\n\t\t#elseif java\n\t\t\treturn postProcessUrlEncode(java.net.URLEncoder.encode(s, \"UTF-8\"));\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.EscapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.quote(s, \"\");\n\t\t#elseif hl\n\t\t\tvar len = 0;\n\t\t\tvar b = @:privateAccess s.bytes.urlEncode(len);\n\t\t\treturn @:privateAccess String.__alloc__(b,len);\n\t\t#elseif lua\n\t\t\ts = lua.NativeStringTools.gsub(s, \"\\n\", \"\\r\\n\");\n\t\t\ts = lua.NativeStringTools.gsub(s, \"([^%w %-%_%.%~])\", function (c) {\n\t\t\t\treturn lua.NativeStringTools.format(\"%%%02X\", lua.NativeStringTools.byte(c) + '');\n\t\t\t});\n\t\t\ts = lua.NativeStringTools.gsub(s, \" \", \"+\");\n\t\t\treturn s;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n#if java\n\tprivate static function postProcessUrlEncode( s : String ) : String {\n\t\tvar ret = new StringBuf();\n\t\tvar i = 0,\n\t\t    len = s.length;\n\t\twhile (i < len) {\n\t\t\tswitch(_charAt(s, i++)) {\n\t\t\tcase '+'.code:\n\t\t\t\tret.add('%20');\n\t\t\tcase '%'.code if (i <= len - 2):\n\t\t\t\tvar c1 = _charAt(s, i++),\n\t\t\t\t    c2 = _charAt(s, i++);\n\t\t\t\tswitch[c1, c2] {\n\t\t\t\tcase ['2'.code, '1'.code]:\n\t\t\t\t\tret.addChar('!'.code);\n\t\t\t\tcase ['2'.code, '7'.code]:\n\t\t\t\t\tret.addChar('\\''.code);\n\t\t\t\tcase ['2'.code, '8'.code]:\n\t\t\t\t\tret.addChar('('.code);\n\t\t\t\tcase ['2'.code, '9'.code]:\n\t\t\t\t\tret.addChar(')'.code);\n\t\t\t\tcase ['7'.code, 'E'.code] | ['7'.code, 'e'.code]:\n\t\t\t\t\tret.addChar('~'.code);\n\t\t\t\tcase _:\n\t\t\t\t\tret.addChar('%'.code);\n\t\t\t\t\tret.addChar(cast c1);\n\t\t\t\t\tret.addChar(cast c2);\n\t\t\t\t}\n\t\t\tcase chr:\n\t\t\t\tret.addChar(cast chr);\n\t\t\t}\n\t\t}\n\t\treturn ret.toString();\n\t}\n#end\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp && !lua) inline #end public static function urlDecode( s : String ) : String {\n\t\t#if flash\n\t\t\treturn untyped __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif neko\n\t\t\treturn untyped new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn untyped decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn untyped s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn untyped cs.system.Uri.UnescapeDataString(s);\n\t\t#elseif python\n\t\t\treturn python.lib.urllib.Parse.unquote(s);\n\t\t#elseif hl\n\t\t\tvar len = 0;\n\t\t\tvar b = @:privateAccess s.bytes.urlDecode(len);\n\t\t\treturn @:privateAccess String.__alloc__(b,len);\n\t\t#elseif lua\n\t\t\ts = lua.NativeStringTools.gsub (s, \"+\", \" \");\n\t\t\ts = lua.NativeStringTools.gsub (s, \"%%(%x%x)\",\n\t\t\t\tfunction(h) {return lua.NativeStringTools.char(lua.Lua.tonumber(h,16));});\n\t\t\ts = lua.NativeStringTools.gsub (s, \"\\r\\n\", \"\\n\");\n\t\t\treturn s;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: `htmlUnescape(htmlEscape(s)) == s`\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is `null`, the result is unspecified.\n\n\t\tIf `start` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#elseif cpp\n\t\tif (s.length<start.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str();\n\t\tvar p1 = start.c_str();\n\t\tfor(i in 0...start.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#elseif hl\n\t\treturn @:privateAccess (s.length >= start.length && s.bytes.compare(0,start.bytes,0,start.length<<1) == 0);\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is `null`, the result is unspecified.\n\n\t\tIf `end` is the empty String `\"\"`, the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#elseif cpp\n\t\tif (s.length<end.length)\n\t\t\treturn false;\n\t\tvar p0 = s.c_str().add( s.length-end.length );\n\t\tvar p1 = end.c_str();\n\t\tfor(i in 0...end.length)\n\t\t\tif ( p0.at(i) != p1.at(i) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t\t#elseif hl\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn @:privateAccess (slen >= elen && s.bytes.compare((slen - elen) << 1, end.bytes, 0, elen << 1) == 0);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String `\"\"`, or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\t#if (python || lua)\n\t\tif (s.length == 0 || pos < 0 || pos >= s.length) return false;\n\t\t#end\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls `isSpace()` to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String `\"\"` or consists only of space characters, the\n\t\tresult is the empty String `\"\"`.\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for `ltrim(rtrim(s))`.\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String `\"\"` or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurrences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String `\"\"`, `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String `\"\"`, `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits `length` equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\t#if python\n\t\tif (digits != null && s.length < digits) {\n\t\t\tvar diff = digits - s.length;\n\t\t\tfor (_ in 0...diff) {\n\t\t\t\ts = \"0\" + s;\n\t\t\t}\n\t\t}\n\t\t#else\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\t#end\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`, or an\n\t\tend-of-file indicator at if `position` equals `s.length`.\n\n\t\tThis method is faster than `String.charCodeAt()` on some platforms, but\n\t\tthe result is unspecified if `index` is negative or greater than\n\t\t`s.length`.\n\n\t\tEnd of file status can be checked by calling `StringTools.isEof()` with\n\t\tthe returned value as argument.\n\n\t\tThis operation is not guaranteed to work if `s` contains the `\\0`\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn untyped s.cca(index);\n\t\t#elseif flash\n\t\treturn untyped s.cca(index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(s[index], Int) : -1;\n\t\t#elseif js\n\t\treturn (untyped s).charCodeAt(index);\n\t\t#elseif python\n\t\treturn if (index >= s.length) -1 else python.internal.UBuiltins.ord(python.Syntax.arrayAccess(s, index));\n\t\t#elseif hl\n\t\treturn @:privateAccess s.bytes.getUI16(index << 1);\n\t\t#elseif lua\n\t\treturn lua.NativeStringTools.byte(s,index+1);\n\t\t#else\n\t\treturn untyped s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash || cpp || hl)\n\t\treturn c == 0;\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif (neko || lua)\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#elseif python\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Unix.\n\t\tThe input will be quoted, or escaped if necessary.\n\t*/\n\tpublic static function quoteUnixArg(argument:String):String {\n\t\t// Based on cpython's shlex.quote().\n\t\t// https://hg.python.org/cpython/file/a3f076d4f54f/Lib/shlex.py#l278\n\n\t\tif (argument == \"\")\n\t\t\treturn \"''\";\n\n\t\tif (!~/[^a-zA-Z0-9_@%+=:,.\\/-]/.match(argument))\n\t\t\treturn argument;\n\n\t\t// use single quotes, and put single quotes into double quotes\n\t\t// the string $'b is then quoted as '$'\"'\"'b'\n\t\treturn \"'\" + replace(argument, \"'\", \"'\\\"'\\\"'\") + \"'\";\n\t}\n\n\t/**\n\t\tCharacter codes of the characters that will be escaped by `quoteWinArg(_, true)`.\n\t*/\n\tpublic static var winMetaCharacters = [\" \".code, \"(\".code, \")\".code, \"%\".code, \"!\".code, \"^\".code, \"\\\"\".code, \"<\".code, \">\".code, \"&\".code, \"|\".code, \"\\n\".code, \"\\r\".code, \",\".code, \";\".code];\n\n\t/**\n\t\tReturns a String that can be used as a single command line argument\n\t\ton Windows.\n\t\tThe input will be quoted, or escaped if necessary, such that the output\n\t\twill be parsed as a single argument using the rule specified in\n\t\thttp://msdn.microsoft.com/en-us/library/ms880421\n\n\t\tExamples:\n\t\t```\n\t\tquoteWinArg(\"abc\") == \"abc\";\n\t\tquoteWinArg(\"ab c\") == '\"ab c\"';\n\t\t```\n\t*/\n\tpublic static function quoteWinArg(argument:String, escapeMetaCharacters:Bool):String {\n\t\t// If there is no space, tab, back-slash, or double-quotes, and it is not an empty string.\n\t\tif (!~/^[^ \\t\\\\\"]+$/.match(argument)) {\n\n\t\t\t// Based on cpython's subprocess.list2cmdline().\n\t\t\t// https://hg.python.org/cpython/file/50741316dd3a/Lib/subprocess.py#l620\n\n\t\t\tvar result = new StringBuf();\n\t\t\tvar needquote = argument.indexOf(\" \") != -1 || argument.indexOf(\"\\t\") != -1 || argument == \"\";\n\n\t\t\tif (needquote)\n\t\t\t\tresult.add('\"');\n\n\t\t\tvar bs_buf = new StringBuf();\n\t\t\tfor (i in 0...argument.length) {\n\t\t\t\tswitch (argument.charCodeAt(i)) {\n\t\t\t\t\tcase \"\\\\\".code:\n\t\t\t\t\t\t// Don't know if we need to double yet.\n\t\t\t\t\t\tbs_buf.add(\"\\\\\");\n\t\t\t\t\tcase '\"'.code:\n\t\t\t\t\t\t// Double backslashes.\n\t\t\t\t\t\tvar bs = bs_buf.toString();\n\t\t\t\t\t\tresult.add(bs);\n\t\t\t\t\t\tresult.add(bs);\n\t\t\t\t\t\tbs_buf = new StringBuf();\n\t\t\t\t\t\tresult.add('\\\\\"');\n\t\t\t\t\tcase c:\n\t\t\t\t\t\t// Normal char\n\t\t\t\t\t\tif (bs_buf.length > 0) {\n\t\t\t\t\t\t\tresult.add(bs_buf.toString());\n\t\t\t\t\t\t\tbs_buf = new StringBuf();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.addChar(c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add remaining backslashes, if any.\n\t\t\tresult.add(bs_buf.toString());\n\n\t\t\tif (needquote) {\n\t\t\t\tresult.add(bs_buf.toString());\n\t\t\t\tresult.add('\"');\n\t\t\t}\n\n\t\t\targument = result.toString();\n\t\t}\n\n\t\tif (escapeMetaCharacters) {\n\t\t\tvar result = new StringBuf();\n\t\t\tfor (i in 0...argument.length) {\n\t\t\t\tvar c = argument.charCodeAt(i);\n\t\t\t\tif (winMetaCharacters.indexOf(c) >= 0) {\n\t\t\t\t\tresult.addChar(\"^\".code);\n\t\t\t\t}\n\t\t\t\tresult.addChar(c);\n\t\t\t}\n\t\t\treturn result.toString();\n\t\t} else {\n\t\t\treturn argument;\n\t\t}\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static inline function getClass<T>( o : T ) : Class<T> {\n\t\treturn if (o == null) null else @:privateAccess js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\tif (a == null)\n\t\t\treturn null;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tcase 9:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]);\n\t\tcase 10:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9]);\n\t\tcase 11:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10]);\n\t\tcase 12:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11]);\n\t\tcase 13:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12]);\n\t\tcase 14:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12],args[13]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f:Dynamic = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"__meta__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static inline function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\treturn ((cast e).__constructs__ : Array<String>).copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic inline static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped __define_feature__(\"Type.allEnums\", e.__empty_constructs__);\n\t}\n\n}\n\n","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage components;\n\nimport edge.IComponent;\n\nclass Spin implements IComponent {\n    public var angle:Float = 0.0;\n    public var speed:Float = 0.0;\n\n    public function new(){}\n}","package edge;\n\nimport edge.Entity;\n\n@:access(edge.Entity)\n@:access(edge.ISystem)\nclass Engine {\n  var mapEntities : Map<Entity, Bool>;\n  var listPhases : Array<Phase>;\n  public function new() {\n    mapEntities = new Map();\n    listPhases = [];\n  }\n\n  public function create(?components : Array<{}>) {\n    var entity = new Entity(this, components);\n    mapEntities.set(entity, true);\n    matchSystems(entity);\n    return entity;\n  }\n\n  public function clear()\n    for(entity in mapEntities.keys())\n      remove(entity);\n\n  function remove(entity : Entity) {\n    eachSystem(function(system) system.__process__.removeEntity(entity));\n    mapEntities.remove(entity);\n    entity.engine = null;\n  }\n\n  public function entities()\n    return mapEntities.keys();\n\n  public function createPhase() {\n    var phase = new Phase(this);\n    listPhases.push(phase);\n    return phase;\n  }\n\n  public function phases()\n    return listPhases.iterator();\n\n  public function eachSystem(f : ISystem -> Void) {\n    for(phase in listPhases)\n      for(system in phase.systems())\n        f(system);\n  }\n\n  // private methods\n  function addSystem(system : ISystem) {\n    eachSystem(\n      function(s)\n        if(s == system)\n          throw 'System \"$system\" already exists in Engine');\n    for(entity in mapEntities.keys())\n      match(entity, system);\n  }\n\n  // TODO, remove all together, not one at the time\n  function removeSystem(system : ISystem)\n    for(entity in mapEntities.keys())\n      system.__process__.removeEntity(entity);\n\n  function updateSystem(system : ISystem, t : Float)\n    return system.__process__.update(this, t);\n\n  function matchSystems(entity : Entity)\n    eachSystem(function(system) match(entity, system));\n\n  inline function match(entity : Entity, system : ISystem)\n    system.__process__.addEntity(entity);\n}\n","package edge;\n\nusing thx.Arrays;\nusing thx.Functions;\n\n@:access(edge.Engine)\nclass Entity {\n  var map : Map<String, {}>;\n  public var engine(default, null) : Engine;\n  function new(engine : Engine, ?components : Array<{}>) {\n    this.engine = engine;\n    this.map = new Map();\n    if(null != components)\n      addMany(components);\n  }\n\n  public function add(component : {}) {\n    if(null == engine) return;\n    _add(component);\n    engine.matchSystems(this);\n  }\n\n  public function addMany(components : Array<{}>) {\n    if(null == engine) return;\n    components.map.fn(_add(_));\n    engine.matchSystems(this);\n  }\n\n  public function destroy() {\n    if(null == engine) return;\n    engine.remove(this);\n    map = new Map();\n  }\n\n  inline public function get<T>(type : Class<T>): Null<T>\n    return cast map.get(Type.getClassName(type));\n\n  public function exists(component : {})\n    return existsType(Type.getClass(component));\n\n  public function existsType(type : Class<{}>)\n    return map.exists(Type.getClassName(type));\n\n  public function remove(component : {}) {\n    _remove(component);\n    engine.matchSystems(this);\n  }\n\n  public function removeMany(components : Array<{}>) {\n    components.map.fn(_remove(_));\n    engine.matchSystems(this);\n  }\n\n  public function removeType(type : Class<{}>) {\n    _removeTypeName(Type.getClassName(type));\n    engine.matchSystems(this);\n  }\n\n  public function removeTypes(types : Array<Class<{}>>) {\n    types.map.fn(_removeTypeName(Type.getClassName(_)));\n    engine.matchSystems(this);\n  }\n\n  inline public function components()\n    return map.iterator();\n\n  function _add(component : {}) {\n    var type = key(component);\n    if(map.exists(type))\n      remove(map.get(type));\n    map.set(type, component);\n  }\n\n  function _remove(component : {}) {\n    var type = key(component);\n    _removeTypeName(type);\n  }\n\n  function _removeTypeName(type : String)\n    map.remove(type);\n\n  function key(component : {}) {\n    var t : Class<Dynamic> = Type.getClass(component),\n        s = Type.getSuperClass(t);\n    while(s != null && s != edge.IComponent) {\n      t = s;\n      s = Type.getSuperClass(t);\n    }\n    return Type.getClassName(t);\n  }\n}\n","package edge;\n\nimport edge.core.NodeSystem;\nimport edge.core.NodeSystemIterator;\n\n@:access(edge.Engine.addSystem)\n@:access(edge.Engine.removeSystem)\n@:access(edge.Engine.updateSystem)\n@:access(edge.core.NodeSystem)\nclass Phase {\n  var first : NodeSystem;\n  var last : NodeSystem;\n  var mapSystem : Map<ISystem, NodeSystem>;\n  var mapType : Map<String, ISystem>;\n  var engine : Engine;\n  var phases : Array<Phase>;\n  public var enabled : Bool;\n  public function new(engine : Engine) {\n    this.engine = engine;\n    mapSystem = new Map();\n    mapType = new Map();\n    phases = [];\n    enabled = true;\n  }\n\n  public function add(system : ISystem) {\n    remove(system);\n    var node = createNode(system);\n    if(null == first) {\n      first = node;\n      last = node;\n    } else {\n      node.prev = last;\n      last.next = node;\n      last = node;\n    }\n  }\n\n  public function createPhase() {\n    var phase = engine.createPhase();\n    phases.push(phase);\n    return phase;\n  }\n\n  public function clearSystems()\n    for(system in systems())\n      remove(system);\n\n  public function insertBefore(ref : ISystem, system : ISystem) {\n    var noderef = mapSystem.get(ref);\n    if(null == noderef)\n      throw 'Phase.insertBefore: unable to find $ref system';\n    var node = createNode(system);\n    if(noderef == first) {\n      node.next = noderef;\n      noderef.prev = node;\n      first = node;\n    } else {\n      var prev = noderef.prev;\n      prev.next = node;\n      node.prev = prev;\n      node.next = noderef;\n      noderef.prev = node;\n    }\n  }\n\n  public function insertAfter(ref : ISystem, system : ISystem) {\n    var noderef = mapSystem.get(ref);\n    if(null == noderef)\n      throw 'Phase.insertAfter: unable to find $ref system';\n    var node = createNode(system);\n    if(noderef == last) {\n      node.prev = noderef;\n      noderef.next = node;\n      last = node;\n    } else {\n      var next = noderef.next;\n      next.prev = node;\n      node.next = next;\n      node.prev = noderef;\n      noderef.next = node;\n    }\n  }\n\n  public function remove(system : ISystem) {\n    var node = mapSystem.get(system);\n    mapType.remove(key(system));\n    if(null == node)\n      return;\n    engine.removeSystem(system);\n    mapSystem.remove(system);\n    if(node == first && node == last) {\n      first = last = null;\n    } else if(node == first) {\n      first = node.next;\n      node.next.prev = null;\n    } else if(node == last) {\n      last = node.prev;\n      node.prev.next = null;\n    } else {\n      node.prev.next = node.next;\n      node.next.prev = node.prev;\n    }\n  }\n\n  public function removeType(cls : Class<Dynamic>) {\n    var system = mapType.get(Type.getClassName(cls));\n    if(null == system)\n      throw 'type system ${Type.getClassName(cls)} is not included in this Phase';\n    return remove(system);\n  }\n\n  public function systems()\n    return new NodeSystemIterator(first);\n\n  public function update(t : Float) {\n    if(!enabled) return;\n    var result;\n    for(system in systems()) {\n      result = engine.updateSystem(system, t);\n      if(!result) return;\n    }\n    for(phase in phases) {\n      phase.update(t);\n    }\n  }\n\n  function createNode(system : ISystem) {\n    var node = new NodeSystem(system);\n    mapSystem.set(system, node);\n    mapType.set(key(system), system);\n    engine.addSystem(system);\n    return node;\n  }\n\n  function key(system : ISystem)\n    return Type.getClassName(Type.getClass(system));\n}\n","package edge;\n\nclass View<T : {}> {\n  public var count(default, null) : Int;\n  var map : Map<Entity, T>;\n  public function new() {\n    map = new Map();\n    count = 0;\n  }\n\n  // TODO optimize\n  public function iterator() : Iterator<ViewData<T>> {\n    var keys = map.keys(),\n        holder = { entity : null, data : null };\n    return {\n      hasNext : function() {\n        return keys.hasNext();\n      },\n      next : function() {\n        var key = keys.next();\n        holder.entity = key;\n        holder.data = map.get(key);\n        return holder;\n      }\n    };\n  }\n\n  function tryAdd(entity : Entity, data : T) {\n    if(map.exists(entity)) return false;\n    map.set(entity, data);\n    count++;\n    return true;\n  }\n\n  function tryRemove(entity : Entity) : T {\n    var o = map.get(entity);\n    if(null == o) return null;\n    map.remove(entity);\n    count--;\n    return o;\n  }\n}","package edge.core;\n\nclass NodeSystem {\n  public var system(default, null) : ISystem;\n  public var next(default, null) : NodeSystem;\n  public var prev(default, null) : NodeSystem;\n\n  public function new(system : ISystem) {\n    this.system = system;\n  }\n}","package edge.core;\n\nclass NodeSystemIterator {\n  var node : NodeSystem;\n  public function new(node : NodeSystem) {\n    this.node = node;\n  }\n\n  public function hasNext()\n    return null != node;\n\n  public function next() {\n    var system = node.system;\n    node = node.next;\n    return system;\n  }\n}","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\n/**\n\tElements return by `CallStack` methods.\n**/\nenum StackItem {\n\tCFunction;\n\tModule( m : String );\n\tFilePos( s : Null<StackItem>, file : String, line : Int );\n\tMethod( classname : String, method : String );\n\tLocalFunction( ?v : Int );\n}\n\n/**\n\tGet information about the call stack.\n**/\nclass CallStack {\n\t#if js\n\tstatic var lastException:js.Error;\n\n\tstatic function getStack(e:js.Error):Array<StackItem> {\n\t\tif (e == null) return [];\n\t\t// https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\t\tvar oldValue = (untyped Error).prepareStackTrace;\n\t\t(untyped Error).prepareStackTrace = function (error, callsites :Array<Dynamic>) {\n\t\t\tvar stack = [];\n\t\t\tfor (site in callsites) {\n\t\t\t\tif (wrapCallSite != null) site = wrapCallSite(site);\n\t\t\t\tvar method = null;\n\t\t\t\tvar fullName :String = site.getFunctionName();\n\t\t\t\tif (fullName != null) {\n\t\t\t\t\tvar idx = fullName.lastIndexOf(\".\");\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tvar className = fullName.substr(0, idx);\n\t\t\t\t\t\tvar methodName = fullName.substr(idx+1);\n\t\t\t\t\t\tmethod = Method(className, methodName);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.push(FilePos(method, site.getFileName(), site.getLineNumber()));\n\t\t\t}\n\t\t\treturn stack;\n\t\t}\n\t\tvar a = makeStack(e.stack);\n\t\t(untyped Error).prepareStackTrace = oldValue;\n\t\treturn a;\n\t}\n\n\t// support for source-map-support module\n\t@:noCompletion\n\tpublic static var wrapCallSite:Dynamic->Dynamic;\n\t#end\n\n\t/**\n\t\tReturn the call stack elements, or an empty array if not available.\n\t**/\n\tpublic static function callStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\tvar a = makeStack(untyped __dollar__callstack());\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a = makeStack( new flash.errors.Error().getStackTrace() );\n\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\treturn makeStack(\"%s\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_call_stack(true);\n\t\t\treturn makeStack(s);\n\t\t#elseif js\n\t\t\ttry {\n\t\t\t\tthrow new js.Error();\n\t\t\t} catch( e : Dynamic ) {\n\t\t\t\tvar a = getStack(e);\n\t\t\t\ta.shift(); // remove Stack.callStack()\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.lang.Thread.currentThread().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(1, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar infos = python.lib.Traceback.extract_stack();\n\t\t\tinfos.pop();\n\t\t\tinfos.reverse();\n\t\t\tfor (elem in infos)\n\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\treturn stack;\n\t\t#elseif lua\n\t\t\tvar stack = [];\n\t\t\tvar infos = lua.Debug.traceback();\n\t\t\tvar luastack = infos.split(\"\\n\").slice(2,-1);\n\t\t\tfor (s in luastack){\n\t\t\t\tvar parts = s.split(\":\");\n\t\t\t\tvar file  = parts[0];\n\t\t\t\tvar line  = parts[1];\n\t\t\t\t// TODO: Give more information for FilePos\n\t\t\t\tstack.push(FilePos(null, file, Std.parseInt(line)));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#elseif hl\n\t\t\ttry {\n\t\t\t\tthrow null;\n\t\t\t} catch( e : Dynamic ) {\n\t\t\t\tvar st = _getExceptionStack();\n\t\t\t\treturn makeStack(st.length > 2 ? st.sub(2,st.length - 2) : st);\n\t\t\t}\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t#if hl\n\t@:hlNative(\"std\", \"exception_stack\") static function _getExceptionStack() : hl.NativeArray<hl.Bytes> { return null; }\n\t#end\n\n\t/**\n\t\tReturn the exception stack : this is the stack elements between\n\t\tthe place the last exception was thrown and the place it was\n\t\tcaught, or an empty array if not available.\n\t**/\n\t#if cpp @:noDebug #end /* Do not mess up the exception stack */\n\tpublic static function exceptionStack() : Array<StackItem> {\n\t\t#if neko\n\t\t\treturn makeStack(untyped __dollar__excstack());\n\t\t#elseif as3\n\t\t\treturn new Array();\n\t\t#elseif hl\n\t\t\treturn makeStack(_getExceptionStack());\n\t\t#elseif flash\n\t\t\tvar err : flash.errors.Error = untyped flash.Boot.lastError;\n\t\t\tif( err == null ) return new Array();\n\t\t\tvar a = makeStack( err.getStackTrace() );\n\t\t\tvar c = callStack();\n\t\t\tvar i = c.length - 1;\n\t\t\twhile( i > 0 ) {\n\t\t\t\tif( Std.string(a[a.length-1]) == Std.string(c[i]) )\n\t\t\t\t\ta.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\treturn makeStack(\"%e\");\n\t\t#elseif cpp\n\t\t\tvar s:Array<String> = untyped __global__.__hxcpp_get_exception_stack();\n\t\t\treturn makeStack(s);\n\t\t#elseif java\n\t\t\tvar stack = [];\n\t\t\tfor ( el in java.internal.Exceptions.currentException().getStackTrace() ) {\n\t\t\t\tvar className = el.getClassName();\n\t\t\t\tvar methodName = el.getMethodName();\n\t\t\t\tvar fileName = el.getFileName();\n\t\t\t\tvar lineNumber = el.getLineNumber();\n\t\t\t\tvar method = Method( className, methodName );\n\t\t\t\tif ( fileName != null || lineNumber >= 0 ) {\n\t\t\t\t\tstack.push( FilePos( method, fileName, lineNumber ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstack.push( method );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// stack.shift();\n\t\t\tstack.shift();\n\t\t\tstack.pop();\n\t\t\treturn stack;\n\t\t#elseif cs\n\t\t\treturn makeStack(new cs.system.diagnostics.StackTrace(cs.internal.Exceptions.exception, true));\n\t\t#elseif python\n\t\t\tvar stack = [];\n\t\t\tvar exc = python.lib.Sys.exc_info();\n\t\t\tif (exc._3 != null)\n\t\t\t{\n\t\t\t\tvar infos = python.lib.Traceback.extract_tb(exc._3);\n\t\t\t\tinfos.reverse();\n\t\t\t\tfor (elem in infos)\n\t\t\t\t\tstack.push(FilePos(null, elem._1, elem._2));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#elseif js\n\t\t\treturn untyped __define_feature__(\"haxe.CallStack.exceptionStack\", getStack(lastException));\n\t\t#else\n\t\t\treturn []; // Unsupported\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a representation of the stack as a printable string.\n\t**/\n\tpublic static function toString( stack : Array<StackItem> ) {\n\t\tvar b = new StringBuf();\n\t\tfor( s in stack ) {\n\t\t\tb.add(\"\\nCalled from \");\n\t\t\titemToString(b,s);\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tprivate static function itemToString( b : StringBuf, s ) {\n\t\tswitch( s ) {\n\t\tcase CFunction:\n\t\t\tb.add(\"a C function\");\n\t\tcase Module(m):\n\t\t\tb.add(\"module \");\n\t\t\tb.add(m);\n\t\tcase FilePos(s,file,line):\n\t\t\tif( s != null ) {\n\t\t\t\titemToString(b,s);\n\t\t\t\tb.add(\" (\");\n\t\t\t}\n\t\t\tb.add(file);\n\t\t\tb.add(\" line \");\n\t\t\tb.add(line);\n\t\t\tif( s != null ) b.add(\")\");\n\t\tcase Method(cname,meth):\n\t\t\tb.add(cname);\n\t\t\tb.add(\".\");\n\t\t\tb.add(meth);\n\t\tcase LocalFunction(n):\n\t\t\tb.add(\"local function #\");\n\t\t\tb.add(n);\n\t\t}\n\t}\n\n\t#if cpp @:noDebug #end /* Do not mess up the exception stack */\n\tprivate static function makeStack(s #if cs : cs.system.diagnostics.StackTrace #elseif hl : hl.NativeArray<hl.Bytes> #end) {\n\t\t#if neko\n\t\t\tvar a = new Array();\n\t\t\tvar l = untyped __dollar__asize(s);\n\t\t\tvar i = 0;\n\t\t\twhile( i < l ) {\n\t\t\t\tvar x = s[i++];\n\t\t\t\tif( x == null )\n\t\t\t\t\ta.unshift(CFunction);\n\t\t\t\telse if( untyped __dollar__typeof(x) == __dollar__tstring )\n\t\t\t\t\ta.unshift(Module(new String(x)));\n\t\t\t\telse\n\t\t\t\t\ta.unshift(FilePos(null,new String(untyped x[0]),untyped x[1]));\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif flash\n\t\t\tvar a = new Array();\n\t\t\tvar r = ~/at ([^\\/]+?)\\$?(\\/[^\\(]+)?\\(\\)(\\[(.*?):([0-9]+)\\])?/;\n\t\t\tvar rlambda = ~/^MethodInfo-([0-9]+)$/g;\n\t\t\twhile( r.match(s) ) {\n\t\t\t\tvar cl = r.matched(1).split(\"::\").join(\".\");\n\t\t\t\tvar meth = r.matched(2);\n\t\t\t\tvar item;\n\t\t\t\tif( meth == null ) {\n\t\t\t\t\tif( rlambda.match(cl) )\n\t\t\t\t\t\titem = LocalFunction(Std.parseInt(rlambda.matched(1)));\n\t\t\t\t\telse\n\t\t\t\t\t\titem = Method(cl,\"new\");\n\t\t\t\t} else\n\t\t\t\t\titem = Method(cl,meth.substr(1));\n\t\t\t\tif( r.matched(3) != null )\n\t\t\t\t\titem = FilePos( item, r.matched(4), Std.parseInt(r.matched(5)) );\n\t\t\t\ta.push(item);\n\t\t\t\ts = r.matchedRight();\n\t\t\t}\n\t\t\treturn a;\n\t\t#elseif php\n\t\t\tif (!untyped __call__(\"isset\", __var__(\"GLOBALS\", s)))\n\t\t\t\treturn [];\n\t\t\tvar a : Array<String> = untyped __var__(\"GLOBALS\", s);\n\t\t\tvar m = [];\n\t\t\tfor( i in 0...a.length - ((s == \"%s\") ? 2 : 0)) {\n\t\t\t\tvar d = a[i].split(\"::\");\n\t\t\t\tm.unshift(Method(d[0],d[1]));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif cpp\n\t\t\tvar stack : Array<String> = s;\n\t\t\tvar m = new Array<StackItem>();\n\t\t\tfor(func in stack) {\n\t\t\t\tvar words = func.split(\"::\");\n\t\t\t\tif (words.length==0)\n\t\t\t\t\tm.push(CFunction)\n\t\t\t\telse if (words.length==2)\n\t\t\t\t\tm.push(Method(words[0],words[1]));\n\t\t\t\telse if (words.length==4)\n\t\t\t\t\tm.push(FilePos( Method(words[0],words[1]),words[2],Std.parseInt(words[3])));\n\t\t\t}\n\t\t\treturn m;\n\t\t#elseif js\n\t\t\tif (s == null) {\n\t\t\t\treturn [];\n\t\t\t} else if ((untyped __js__(\"typeof\"))(s) == \"string\") {\n\t\t\t\t// Return the raw lines in browsers that don't support prepareStackTrace\n\t\t\t\tvar stack : Array<String> = s.split(\"\\n\");\n\t\t\t\tif( stack[0] == \"Error\" ) stack.shift();\n\t\t\t\tvar m = [];\n\t\t\t\tvar rie10 = ~/^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$/;\n\t\t\t\tfor( line in stack ) {\n\t\t\t\t\tif( rie10.match(line) ) {\n\t\t\t\t\t\tvar path = rie10.matched(1).split(\".\");\n\t\t\t\t\t\tvar meth = path.pop();\n\t\t\t\t\t\tvar file = rie10.matched(2);\n\t\t\t\t\t\tvar line = Std.parseInt(rie10.matched(3));\n\t\t\t\t\t\tm.push(FilePos( meth == \"Anonymous function\" ? LocalFunction() : meth == \"Global code\" ? null : Method(path.join(\".\"),meth), file, line ));\n\t\t\t\t\t} else\n\t\t\t\t\t\tm.push(Module(StringTools.trim(line))); // A little weird, but better than nothing\n\t\t\t\t}\n\t\t\t\treturn m;\n\t\t\t} else {\n\t\t\t\treturn cast s;\n\t\t\t}\n\t\t#elseif cs\n\t\t\tvar stack = [];\n\t\t\tfor (i in 0...s.FrameCount)\n\t\t\t{\n\t\t\t\tvar frame = s.GetFrame(i);\n\t\t\t\tvar m = frame.GetMethod();\n\n\t\t\t\tif (m == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar method = StackItem.Method(m.ReflectedType.ToString(), m.Name);\n\n\t\t\t\tvar fileName = frame.GetFileName();\n\t\t\t\tvar lineNumber = frame.GetFileLineNumber();\n\n\t\t\t\tif (fileName != null || lineNumber >= 0)\n\t\t\t\t\tstack.push(FilePos(method, fileName, lineNumber));\n\t\t\t\telse\n\t\t\t\t\tstack.push(method);\n\t\t\t}\n\t\t\treturn stack;\n\t\t#elseif hl\n\t\t\tvar stack = [];\n\t\t\tvar r = ~/^([A-Za-z0-9.$_]+)\\.([A-Za-z0-9_]+)\\((.+):([0-9]+)\\)$/;\n\t\t\tfor( i in 0...s.length-1 ) {\n\t\t\t\tvar str = @:privateAccess String.fromUCS2(s[i]);\n\t\t\t\tif( r.match(str) )\n\t\t\t\t\tstack.push(FilePos(Method(r.matched(1), r.matched(2)), r.matched(3), Std.parseInt(r.matched(4))));\n\t\t\t\telse\n\t\t\t\t\tstack.push(Module(str));\n\t\t\t}\n\t\t\treturn stack;\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe;\n\nusing haxe.Int64;\n\n /**\n\tA cross-platform signed 64-bit integer.\n\tInt64 instances can be created from two 32-bit words using `Int64.make()`.\n **/\n#if flash\n@:notNull\n#end\nabstract Int64(__Int64) from __Int64 to __Int64\n{\n\tprivate inline function new( x : __Int64 )\n\t\tthis = x;\n\n\t/**\n\t\tMakes a copy of `this` Int64.\n\t**/\n\tpublic inline function copy():Int64\n\t\treturn make( high, low );\n\n\t/**\n\t\tConstruct an Int64 from two 32-bit words `high` and `low`.\n\t**/\n\tpublic static inline function make( high:Int32, low:Int32 ) : Int64\n\t\treturn new Int64( new __Int64(high, low) );\n\n\t/**\n\t\tReturns an Int64 with the value of the Int `x`.\n\t\t`x` is sign-extended to fill 64 bits.\n\t**/\n\t@:from public static inline function ofInt( x : Int ) : Int64\n#if lua\n\t\treturn make( (x:Int32) >> 31, (x:Int32));\n#else\n\t\treturn make( x >> 31, x );\n#end\n\n\t/**\n\t\tReturns an Int with the value of the Int64 `x`.\n\t\tThrows an exception  if `x` cannot be represented in 32 bits.\n\t**/\n\tpublic static inline function toInt( x : Int64 ) : Int {\n\t\tif( x.high != x.low >> 31 )\n\t\t\tthrow \"Overflow\";\n\n\t\treturn x.low;\n\t}\n\n\t/**\n\t\tReturns whether the value `val` is of type `haxe.Int64`\n\t**/\n\tinline public static function is( val : Dynamic ) : Bool\n\t\treturn Std.is(val,__Int64);\n\n\t/**\n\t\tReturns the high 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use high instead\")\n\tpublic static inline function getHigh( x : Int64 ) : Int32\n\t\treturn x.high;\n\n\t/**\n\t\tReturns the low 32-bit word of `x`.\n\t**/\n\t@:deprecated(\"Use low instead\")\n\tpublic static inline function getLow( x : Int64 ) : Int32\n\t\treturn x.low;\n\n\t/**\n\t\tReturns `true` if `x` is less than zero.\n\t**/\n\tpublic static inline function isNeg( x : Int64) : Bool\n\t\treturn x.high < 0;\n\n\t/**\n\t\tReturns `true` if `x` is exactly zero.\n\t**/\n\tpublic static inline function isZero( x : Int64 ) : Bool\n\t\treturn x == 0;\n\n\t/**\n\t\tCompares `a` and `b` in signed mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function compare( a : Int64, b : Int64 ) : Int {\n\t\tvar v = a.high - b.high;\n\t\tv = if( v != 0 ) v else Int32.ucompare(a.low, b.low);\n\t\treturn a.high < 0 ? (b.high < 0 ? v : -1) : (b.high >= 0 ? v : 1);\n\t}\n\n\t/**\n\t\tCompares `a` and `b` in unsigned mode.\n\t\tReturns a negative value if `a < b`, positive if `a > b`,\n\t\tor 0 if `a == b`.\n\t**/\n\tpublic static inline function ucompare( a : Int64, b : Int64 ) : Int {\n\t\tvar v = Int32.ucompare(a.high, b.high);\n\t\treturn if( v != 0 ) v else Int32.ucompare(a.low, b.low);\n\t}\n\n\t/**\n\t\tReturns a signed decimal `String` representation of `x`.\n\t**/\n\tpublic static inline function toStr(x:Int64) : String\n\t\treturn x.toString();\n\n\t#if as3 public #else private #end function toString() : String\n\t{\n\t\tvar i : Int64 = cast this;\n\t\tif ( i == 0 )\n\t\t\treturn \"0\";\n\t\tvar str = \"\";\n\t\tvar neg = false;\n\t\tif( i.isNeg() ) {\n\t\t\tneg = true;\n\t\t\t// i = -i; cannot negate here as --9223372036854775808 = -9223372036854775808\n\t\t}\n\t\tvar ten : Int64 = 10;\n\t\twhile( i != 0 ) {\n\t\t\tvar r = i.divMod( ten );\n\t\t\tif (r.modulus.isNeg()) {\n\t\t\t\tstr = Int64.neg(r.modulus).low + str;\n\t\t\t\ti = Int64.neg(r.quotient);\n\t\t\t} else {\n\t\t\t\tstr = r.modulus.low + str;\n\t\t\t\ti = r.quotient;\n\t\t\t}\n\t\t}\n\t\tif( neg ) str = \"-\" + str;\n\t\treturn str;\n\t}\n\n\tpublic static inline function parseString( sParam : String ) : Int64 {\n\t\treturn Int64Helper.parseString( sParam );\n\t}\n\n\tpublic static inline function fromFloat( f : Float ) : Int64 {\n\t\treturn Int64Helper.fromFloat( f );\n\t}\n\n\t/**\n\t\tPerforms signed integer divison of `dividend` by `divisor`.\n\t\tReturns `{ quotient : Int64, modulus : Int64 }`.\n\t**/\n\tpublic static function divMod( dividend : Int64, divisor : Int64 ) : { quotient : Int64, modulus : Int64 }\n\t{\n\t\t// Handle special cases of 0 and 1\n\t\tif( divisor.high == 0 )\n\t\t{\n\t\t\tswitch( divisor.low ) {\n\t\t\t\tcase 0: throw \"divide by zero\";\n\t\t\t\tcase 1: return { quotient : dividend.copy(), modulus : 0 };\n\t\t\t}\n\t\t}\n\n\t\tvar divSign = dividend.isNeg() != divisor.isNeg();\n\n\t\tvar modulus = dividend.isNeg() ? -dividend : dividend.copy();\n\t\tdivisor = divisor.isNeg() ? -divisor : divisor;\n\n\t\tvar quotient : Int64 = 0;\n\t\tvar mask : Int64 = 1;\n\n\t\twhile( !divisor.isNeg() ) {\n\t\t\tvar cmp = ucompare( divisor, modulus );\n\t\t\tdivisor <<= 1;\n\t\t\tmask <<= 1;\n\t\t\tif( cmp >= 0 ) break;\n\t\t}\n\n\t\twhile( mask != 0 ) {\n\t\t\tif( ucompare(modulus, divisor) >= 0 ) {\n\t\t\t\tquotient |= mask;\n\t\t\t\tmodulus -= divisor;\n\t\t\t}\n\t\t\tmask >>>= 1;\n\t\t\tdivisor >>>= 1;\n\t\t}\n\n\t\tif( divSign ) quotient = -quotient;\n\t\tif( dividend.isNeg() ) modulus = -modulus;\n\n\t\treturn {\n\t\t\tquotient : quotient,\n\t\t\tmodulus  : modulus\n\t\t};\n\t}\n\n\t/**\n\t\tReturns the negative of `x`.\n\t**/\n\t@:op(-A) public static inline function neg( x : Int64 ) : Int64 {\n\t\tvar high = ~x.high;\n\t\tvar low = -x.low;\n\t\tif( low == 0 )\n\t\t\thigh++;\n\t\treturn make( high, low );\n\t}\n\n\t@:op(++A) private inline function preIncrement() : Int64 {\n\t\tthis = copy();\n\t\tthis.low++;\n\t\tif( this.low == 0 ) this.high++;\n\t\treturn cast this;\n\t}\n\n\t@:op(A++) private inline function postIncrement() : Int64 {\n\t\tvar ret = this;\n\t\tpreIncrement();\n\t\treturn ret;\n\t}\n\n\t@:op(--A) private inline function preDecrement() : Int64 {\n\t\tthis = copy();\n\t\tif( this.low == 0 ) this.high--;\n\t\tthis.low--;\n\t\treturn cast this;\n\t}\n\n\t@:op(A--) private inline function postDecrement() : Int64 {\n\t\tvar ret = this;\n\t\tpreDecrement();\n\t\treturn ret;\n\t}\n\n\t/**\n\t\tReturns the sum of `a` and `b`.\n\t**/\n\t@:op(A + B) public static inline function add( a : Int64, b : Int64 ) : Int64 {\n\t\tvar high = a.high + b.high;\n\t\tvar low = a.low + b.low;\n\t\tif( Int32.ucompare( low, a.low ) < 0 ) high++;\n\t\treturn make( high, low );\n\t}\n\n\t@:op(A + B) @:commutative private static inline function addInt( a : Int64, b : Int ) : Int64\n\t\treturn add( a, b );\n\n\t/**\n\t\tReturns `a` minus `b`.\n\t**/\n\t@:op(A - B) public static inline function sub( a : Int64, b : Int64 ) : Int64 {\n\t\tvar high = a.high - b.high;\n\t\tvar low = a.low - b.low;\n\t\tif( Int32.ucompare( a.low, b.low ) < 0 ) high--;\n        return make( high, low );\n\t}\n\n\t@:op(A - B) private static inline function subInt( a : Int64, b : Int ) : Int64\n\t\treturn sub( a, b );\n\n\t@:op(A - B) private static inline function intSub( a : Int, b : Int64 ) : Int64\n\t\treturn sub( a, b );\n\n\t/**\n\t\tReturns the product of `a` and `b`.\n\t**/\n\t@:op(A * B) public static #if !lua inline #end function mul( a : Int64, b : Int64 ) : Int64 {\n\t\tvar mask = 0xFFFF;\n\t\tvar al = a.low & mask, ah = a.low >>> 16;\n\t\tvar bl = b.low & mask, bh = b.low >>> 16;\n\t\tvar p00 = al * bl;\n\t\tvar p10 = ah * bl;\n\t\tvar p01 = al * bh;\n\t\tvar p11 = ah * bh;\n\t\tvar low = p00;\n\t\tvar high = p11 + (p01 >>> 16) + (p10 >>> 16);\n\t\tp01 <<= 16;\n\t\tlow += p01;\n\t\tif( Int32.ucompare(low, p01) < 0 ) high++;\n\t\tp10 <<= 16;\n\t\tlow += p10;\n\t\tif( Int32.ucompare(low, p10) < 0 ) high++;\n\t\thigh += a.low * b.high + a.high * b.low;\n\t\treturn make( high, low );\n\t}\n\n\t@:op(A * B) @:commutative private static inline function mulInt( a : Int64, b : Int ) : Int64\n\t\treturn mul( a, b );\n\n\t/**\n\t\tReturns the quotient of `a` divided by `b`.\n\t**/\n\t@:op(A / B) public static inline function div( a : Int64, b : Int64 ) : Int64\n\t\treturn divMod(a, b).quotient;\n\n\t@:op(A / B) private static inline function divInt( a : Int64, b : Int ) : Int64\n\t\treturn div( a, b );\n\n\t@:op(A / B) private static inline function intDiv( a : Int, b : Int64 ) : Int64\n\t\treturn div( a, b ).toInt();\n\n\t/**\n\t\tReturns the modulus of `a` divided by `b`.\n\t**/\n\t@:op(A % B) public static inline function mod( a : Int64, b : Int64 ) : Int64\n\t\treturn divMod(a, b).modulus;\n\n\t@:op(A % B) private static inline function modInt( a : Int64, b : Int ) : Int64\n\t\treturn mod( a, b ).toInt();\n\n\t@:op(A % B) private static inline function intMod( a : Int, b : Int64 ) : Int64\n\t\treturn mod( a, b ).toInt();\n\n\t/**\n\t\tReturns `true` if `a` is equal to `b`.\n\t**/\n\t@:op(A == B) public static inline function eq( a : Int64, b : Int64 ) : Bool\n\t\treturn a.high == b.high && a.low == b.low;\n\n\t@:op(A == B) @:commutative private static inline function eqInt( a : Int64, b : Int ) : Bool\n\t\treturn eq( a, b );\n\n\t/**\n\t\tReturns `true` if `a` is not equal to `b`.\n\t**/\n\t@:op(A != B) public static inline function neq( a : Int64, b : Int64 ) : Bool\n\t\treturn a.high != b.high || a.low != b.low;\n\n\t@:op(A != B) @:commutative private static inline function neqInt( a : Int64, b : Int ) : Bool\n\t\treturn neq(a, b);\n\n\t@:op(A < B) private static inline function lt( a : Int64, b : Int64 ) : Bool\n\t\treturn compare(a, b) < 0;\n\n\t@:op(A < B) private static inline function ltInt( a : Int64, b : Int ) : Bool\n\t\treturn lt(a, b);\n\n\t@:op(A < B) private static inline function intLt( a : Int, b : Int64 ) : Bool\n\t\treturn lt(a, b);\n\n\t@:op(A <= B) private static inline function lte( a : Int64, b : Int64 ) : Bool\n\t\treturn compare(a, b) <= 0;\n\n\t@:op(A <= B) private static inline function lteInt( a : Int64, b : Int ) : Bool\n\t\treturn lte(a, b);\n\n\t@:op(A <= B) private static inline function intLte( a : Int, b : Int64 ) : Bool\n\t\treturn lte(a, b);\n\n\t@:op(A > B) private static inline function gt( a : Int64, b : Int64 ) : Bool\n\t\treturn compare(a, b) > 0;\n\n\t@:op(A > B) private static inline function gtInt( a : Int64, b : Int ) : Bool\n\t\treturn gt(a, b);\n\n\t@:op(A > B) private static inline function intGt( a : Int, b : Int64 ) : Bool\n\t\treturn gt( a, b );\n\n\t@:op(A >= B) private static inline function gte( a : Int64, b : Int64 ) : Bool\n\t\treturn compare(a, b) >= 0;\n\n\t@:op(A >= B) private static inline function gteInt( a : Int64, b : Int ) : Bool\n\t\treturn gte(a, b);\n\n\t@:op(A >= B) private static inline function intGte( a : Int, b : Int64 ) : Bool\n\t\treturn gte(a, b);\n\n\t/**\n\t\tReturns the bitwise NOT of `a`.\n\t**/\n\t@:op(~A) private static inline function complement( a : Int64 ) : Int64\n\t\treturn make( ~a.high, ~a.low );\n\n\t/**\n\t\tReturns the bitwise AND of `a` and `b`.\n\t**/\n\t@:op(A & B) public static inline function and( a : Int64, b : Int64 ) : Int64\n\t\treturn make( a.high & b.high, a.low & b.low );\n\n\t/**\n\t\tReturns the bitwise OR of `a` and `b`.\n\t**/\n\t@:op(A | B) public static inline function or( a : Int64, b : Int64 ) : Int64\n\t\treturn make( a.high | b.high, a.low | b.low );\n\n\t/**\n\t\tReturns the bitwise XOR of `a` and `b`.\n\t**/\n\t@:op(A ^ B) public static inline function xor( a : Int64, b : Int64 ) : Int64\n\t\treturn make( a.high ^ b.high, a.low ^ b.low );\n\n\t/**\n\t\tReturns `a` left-shifted by `b` bits.\n\t**/\n\t@:op(A << B) public static inline function shl( a : Int64, b : Int ) : Int64 {\n\t\tb &= 63;\n\t\treturn if( b == 0 ) a.copy()\n\t\t\telse if( b < 32 ) make( (a.high << b) | (a.low >>> (32-b)), a.low << b)\n\t\t\telse make( a.low << (b-32), 0 );\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in signed mode.\n\t\t`a` is sign-extended.\n\t**/\n\t@:op(A >> B) public static inline function shr( a : Int64, b : Int) : Int64 {\n\t\tb &= 63;\n\t\treturn if( b == 0 ) a.copy()\n\t\t\telse if( b < 32 ) make( a.high >> b, (a.high << (32-b)) | (a.low >>> b) );\n\t\t\telse make( a.high >> 31, a.high >> (b - 32) );\n\t}\n\n\t/**\n\t\tReturns `a` right-shifted by `b` bits in unsigned mode.\n\t\t`a` is padded with zeroes.\n\t**/\n\t@:op(A >>> B) public static inline function ushr( a : Int64, b : Int ) : Int64 {\n\t\tb &= 63;\n\t\treturn if( b == 0 ) a.copy()\n\t\t\telse if( b < 32 ) make( a.high >>> b, (a.high << (32-b)) | (a.low >>> b) );\n\t\t\telse make( 0, a.high >>> (b - 32) );\n\t}\n\n\tpublic var high(get, never) : Int32;\n\tprivate inline function get_high() return this.high;\n\tprivate inline function set_high(x) return this.high = x;\n\n\tpublic var low(get, never) : Int32;\n\tprivate inline function get_low() return this.low;\n\tprivate inline function set_low(x) return this.low = x;\n}\n\n/**\n  * This typedef will fool @:coreApi into thinking that we are using\n  * the same underlying type, even though it might be different on\n  * specific platforms.\n  */\nprivate typedef __Int64 = ___Int64;\n\nprivate class ___Int64 {\n\tpublic var high : Int32;\n\tpublic var low : Int32;\n\n\tpublic inline function new( high, low ) {\n\t\tthis.high = high;\n\t\tthis.low = low;\n\t}\n\n\t/**\n\t\tWe also define toString here to ensure we always get a pretty string\n\t\twhen tracing or calling Std.string. This tends not to happen when\n\t\ttoString is only in the abstract.\n\t**/\n\tpublic function toString() : String\n\t\treturn Int64.toStr( cast this );\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n#if !nodejs\nimport js.html.compat.Uint8Array;\nimport js.html.compat.DataView;\n#end\n\n@:coreApi\nclass Bytes {\n\n\tpublic var length(default,null) : Int;\n\tvar b : js.html.Uint8Array;\n\tvar data : js.html.DataView;\n\n\tfunction new(data:BytesData) {\n\t\tthis.length = data.byteLength;\n\t\tthis.b = new js.html.Uint8Array(data);\n\t\tuntyped {\n\t\t\tb.bufferValue = data; // some impl does not return the same instance in .buffer\n\t\t\tdata.hxBytes = this;\n\t\t\tdata.bytes = this.b;\n\t\t}\n\t}\n\n\tpublic inline function get( pos : Int ) : Int {\n\t\treturn b[pos];\n\t}\n\n\tpublic inline function set( pos : Int, v : Int ) : Void {\n\t\tb[pos] = v & 0xFF; // the &0xFF is necessary for js.html.compat support\n\t}\n\n\tpublic function blit( pos : Int, src : Bytes, srcpos : Int, len : Int ) : Void {\n\t\tif( pos < 0 || srcpos < 0 || len < 0 || pos + len > length || srcpos + len > src.length ) throw Error.OutsideBounds;\n\t\tif( srcpos == 0 && len == src.b.byteLength )\n\t\t\tb.set(src.b,pos);\n\t\telse\n\t\t\tb.set(src.b.subarray(srcpos,srcpos+len),pos);\n\t}\n\n\tpublic function fill( pos : Int, len : Int, value : Int ) : Void {\n\t\tfor( i in 0...len )\n\t\t\tset(pos++, value);\n\t}\n\n\tpublic function sub( pos : Int, len : Int ) : Bytes {\n\t\tif( pos < 0 || len < 0 || pos + len > length ) throw Error.OutsideBounds;\n\t\treturn new Bytes(b.buffer.slice(pos+b.byteOffset,pos+b.byteOffset+len));\n\t}\n\n\tpublic function compare( other : Bytes ) : Int {\n\t\tvar b1 = b;\n\t\tvar b2 = other.b;\n\t\tvar len = (length < other.length) ? length : other.length;\n\t\tfor( i in 0...len )\n\t\t\tif( b1[i] != b2[i] )\n\t\t\t\treturn b1[i] - b2[i];\n\t\treturn length - other.length;\n\t}\n\n\tinline function initData() : Void {\n\t\tif( data == null ) data = new js.html.DataView(b.buffer, b.byteOffset, b.byteLength);\n\t}\n\n\tpublic function getDouble( pos : Int ) : Float {\n\t\tinitData();\n\t\treturn data.getFloat64(pos, true);\n\t}\n\n\tpublic function getFloat( pos : Int ) : Float {\n\t\tinitData();\n\t\treturn data.getFloat32(pos, true);\n\t}\n\n\tpublic function setDouble( pos : Int, v : Float ) : Void {\n\t\tinitData();\n\t\tdata.setFloat64(pos, v, true);\n\t}\n\n\tpublic function setFloat( pos : Int, v : Float ) : Void {\n\t\tinitData();\n\t\tdata.setFloat32(pos, v, true);\n\t}\n\n\tpublic function getUInt16( pos : Int ) : Int {\n\t\tinitData();\n\t\treturn data.getUint16(pos, true);\n\t}\n\n\tpublic function setUInt16( pos : Int, v : Int ) : Void {\n\t\tinitData();\n\t\tdata.setUint16(pos, v, true);\n\t}\n\n\tpublic function getInt32( pos : Int ) : Int {\n\t\tinitData();\n\t\treturn data.getInt32(pos, true);\n\t}\n\n\tpublic function setInt32( pos : Int, v : Int ) : Void {\n\t\tinitData();\n\t\tdata.setInt32(pos, v, true);\n\t}\n\n\tpublic function getInt64( pos : Int ) : haxe.Int64 {\n\t\treturn Int64.make(getInt32(pos + 4),getInt32(pos));\n\t}\n\n\tpublic function setInt64( pos : Int, v : haxe.Int64 ) : Void {\n\t\tsetInt32(pos, v.low);\n\t\tsetInt32(pos + 4, v.high);\n\t}\n\n\tpublic function getString( pos : Int, len : Int ) : String {\n\t\tif( pos < 0 || len < 0 || pos + len > length ) throw Error.OutsideBounds;\n\t\tvar s = \"\";\n\t\tvar b = b;\n\t\tvar fcc = String.fromCharCode;\n\t\tvar i = pos;\n\t\tvar max = pos+len;\n\t\t// utf8-decode and utf16-encode\n\t\twhile( i < max ) {\n\t\t\tvar c = b[i++];\n\t\t\tif( c < 0x80 ) {\n\t\t\t\tif( c == 0 ) break;\n\t\t\t\ts += fcc(c);\n\t\t\t} else if( c < 0xE0 )\n\t\t\t\ts += fcc( ((c & 0x3F) << 6) | (b[i++] & 0x7F) );\n\t\t\telse if( c < 0xF0 ) {\n\t\t\t\tvar c2 = b[i++];\n\t\t\t\ts += fcc( ((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (b[i++] & 0x7F) );\n\t\t\t} else {\n\t\t\t\tvar c2 = b[i++];\n\t\t\t\tvar c3 = b[i++];\n\t\t\t\tvar u = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (b[i++] & 0x7F);\n\t\t\t\t// surrogate pair\n\t\t\t\ts += fcc( (u >> 10) + 0xD7C0 );\n\t\t\t\ts += fcc( (u & 0x3FF) | 0xDC00 );\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\t@:deprecated(\"readString is deprecated, use getString instead\")\n\t@:noCompletion\n\tpublic inline function readString(pos:Int, len:Int):String {\n\t\treturn getString(pos, len);\n\t}\n\n\tpublic function toString() : String {\n\t\treturn getString(0,length);\n\t}\n\n\tpublic function toHex() : String {\n\t\tvar s = new StringBuf();\n\t\tvar chars = [];\n\t\tvar str = \"0123456789abcdef\";\n\t\tfor( i in 0...str.length )\n\t\t\tchars.push(str.charCodeAt(i));\n\t\tfor( i in 0...length ) {\n\t\t\tvar c = get(i);\n\t\t\ts.addChar(chars[c >> 4]);\n\t\t\ts.addChar(chars[c & 15]);\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tpublic inline function getData() : BytesData {\n\t\treturn untyped b.bufferValue;\n\t}\n\n\tpublic static inline function alloc( length : Int ) : Bytes {\n\t\treturn new Bytes(new BytesData(length));\n\t}\n\n\tpublic static function ofString( s : String ) : Bytes {\n\t\tvar a = new Array();\n\t\t// utf16-decode and utf8-encode\n\t\tvar i = 0;\n\t\twhile( i < s.length ) {\n\t\t\tvar c : Int = StringTools.fastCodeAt(s,i++);\n\t\t\t// surrogate pair\n\t\t\tif( 0xD800 <= c && c <= 0xDBFF )\n\t\t\t    c = (c - 0xD7C0 << 10) | (StringTools.fastCodeAt(s,i++) & 0x3FF);\n\t\t\tif( c <= 0x7F )\n\t\t\t\ta.push(c);\n\t\t\telse if( c <= 0x7FF ) {\n\t\t\t\ta.push( 0xC0 | (c >> 6) );\n\t\t\t\ta.push( 0x80 | (c & 63) );\n\t\t\t} else if( c <= 0xFFFF ) {\n\t\t\t\ta.push( 0xE0 | (c >> 12) );\n\t\t\t\ta.push( 0x80 | ((c >> 6) & 63) );\n\t\t\t\ta.push( 0x80 | (c & 63) );\n\t\t\t} else {\n\t\t\t\ta.push( 0xF0 | (c >> 18) );\n\t\t\t\ta.push( 0x80 | ((c >> 12) & 63) );\n\t\t\t\ta.push( 0x80 | ((c >> 6) & 63) );\n\t\t\t\ta.push( 0x80 | (c & 63) );\n\t\t\t}\n\t\t}\n\t\treturn new Bytes(new js.html.Uint8Array(a).buffer);\n\t}\n\n\tpublic static function ofData( b : BytesData ) : Bytes {\n\t\tvar hb = untyped b.hxBytes;\n\t\tif( hb != null ) return hb;\n\t\treturn new Bytes(b);\n\t}\n\n\tpublic inline static function fastGet( b : BytesData, pos : Int ) : Int {\n\t\t// this requires that we have wrapped it with haxe.io.Bytes beforehand\n\t\treturn untyped b.bytes[pos];\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.crypto;\n\n/**\n\tAllows to encode/decode String and bytes using Base64 encoding.\n**/\nclass Base64 {\n\n\tpublic static var CHARS(default,null) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\tpublic static var BYTES(default,null) = haxe.io.Bytes.ofString(CHARS);\n\n\tpublic static function encode( bytes : haxe.io.Bytes, complement = true ) : String {\n\t\tvar str = new BaseCode(BYTES).encodeBytes(bytes).toString();\n\t\tif( complement )\n\t\t\tswitch (bytes.length % 3) {\n\t\t\tcase 1:\n\t\t\t\tstr += \"==\";\n\t\t\tcase 2:\n\t\t\t\tstr += \"=\";\n\t\t\tdefault:\n\t\t\t}\n\t\treturn str;\n\t}\n\n\tpublic static function decode( str : String, complement = true ) : haxe.io.Bytes {\n\t\tif( complement )\n\t\t\twhile( str.charCodeAt(str.length-1) == \"=\".code )\n\t\t\t\tstr = str.substr(0,-1);\n\t\treturn new BaseCode(BYTES).decodeBytes(haxe.io.Bytes.ofString(str));\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.crypto;\n\n/**\n\tAllows to encode/decode String and bytes using a power of two base dictionary.\n**/\nclass BaseCode {\n\n\tvar base : haxe.io.Bytes;\n\tvar nbits : Int;\n\tvar tbl : Array<Int>;\n\n\tpublic function new( base : haxe.io.Bytes ) {\n\t\tvar len = base.length;\n\t\tvar nbits = 1;\n\t\twhile( len > 1 << nbits )\n\t\t\tnbits++;\n\t\tif( nbits > 8 || len != 1 << nbits )\n\t\t\tthrow \"BaseCode : base length must be a power of two.\";\n\t\tthis.base = base;\n\t\tthis.nbits = nbits;\n\t}\n\n\tpublic function encodeBytes( b : haxe.io.Bytes ) : haxe.io.Bytes {\n\t\t#if (neko && !interp)\n\t\treturn haxe.io.Bytes.ofData( base_encode(b.getData(),base.getData()) );\n\t\t#else\n\t\tvar nbits = this.nbits;\n\t\tvar base = this.base;\n\t\tvar size = Std.int(b.length * 8 / nbits);\n\t\tvar out = haxe.io.Bytes.alloc(size + (((b.length * 8) % nbits == 0) ? 0 : 1) );\n\t\tvar buf = 0;\n\t\tvar curbits = 0;\n\t\tvar mask = (1 << nbits) - 1;\n\t\tvar pin = 0;\n\t\tvar pout = 0;\n\t\twhile( pout < size ) {\n\t\t\twhile( curbits < nbits ) {\n\t\t\t\tcurbits += 8;\n\t\t\t\tbuf <<= 8;\n\t\t\t\tbuf |= b.get(pin++);\n\t\t\t}\n\t\t\tcurbits -= nbits;\n\t\t\tout.set(pout++,base.get((buf >> curbits) & mask));\n\t\t}\n\t\tif( curbits > 0 )\n\t\t\tout.set(pout++,base.get((buf << (nbits - curbits)) & mask));\n\t\treturn out;\n\t\t#end\n\t}\n\n\tfunction initTable() {\n\t\tvar tbl = new Array();\n\t\tfor( i in 0...256 )\n\t\t\ttbl[i] = -1;\n\t\tfor( i in 0...base.length )\n\t\t\ttbl[base.get(i)] = i;\n\t\tthis.tbl = tbl;\n\t}\n\n\tpublic function decodeBytes( b : haxe.io.Bytes ) : haxe.io.Bytes {\n\t\t#if (neko && !interp)\n\t\treturn haxe.io.Bytes.ofData( base_decode(b.getData(),base.getData()) );\n\t\t#else\n\t\tvar nbits = this.nbits;\n\t\tvar base = this.base;\n\t\tif( this.tbl == null ) initTable();\n\t\tvar tbl = this.tbl;\n\t\tvar size = (b.length * nbits) >> 3;\n\t\tvar out = haxe.io.Bytes.alloc(size);\n\t\tvar buf = 0;\n\t\tvar curbits = 0;\n\t\tvar pin = 0;\n\t\tvar pout = 0;\n\t\twhile( pout < size ) {\n\t\t\twhile( curbits < 8 ) {\n\t\t\t\tcurbits += nbits;\n\t\t\t\tbuf <<= nbits;\n\t\t\t\tvar i = tbl[b.get(pin++)];\n\t\t\t\tif( i == -1 )\n\t\t\t\t\tthrow \"BaseCode : invalid encoded char\";\n\t\t\t\tbuf |= i;\n\t\t\t}\n\t\t\tcurbits -= 8;\n\t\t\tout.set(pout++,(buf >> curbits) & 0xFF);\n\t\t}\n\t\treturn out;\n\t\t#end\n\t}\n\n\tpublic function encodeString( s : String ) {\n\t\t#if (neko && !interp)\n\t\treturn neko.NativeString.toString( base_encode(neko.NativeString.ofString(s),base.getData()) );\n\t\t#else\n\t\treturn encodeBytes(haxe.io.Bytes.ofString(s)).toString();\n\t\t#end\n\t}\n\n\tpublic function decodeString( s : String ) {\n\t\t#if (neko && !interp)\n\t\treturn neko.NativeString.toString( base_decode(neko.NativeString.ofString(s),base.getData()) );\n\t\t#else\n\t\treturn decodeBytes(haxe.io.Bytes.ofString(s)).toString();\n\t\t#end\n\t}\n\n\tpublic static function encode( s : String, base : String ) {\n\t\tvar b = new BaseCode(haxe.io.Bytes.ofString(base));\n\t\treturn b.encodeString(s);\n\t}\n\n\tpublic static function decode( s : String, base : String ) {\n\t\tvar b = new BaseCode(haxe.io.Bytes.ofString(base));\n\t\treturn b.decodeString(s);\n\t}\n\n\t#if neko\n\tprivate static var base_encode = neko.Lib.load(\"std\",\"base_encode\",2);\n\tprivate static var base_decode = neko.Lib.load(\"std\",\"base_decode\",2);\n\t#end\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class IntMap<T> implements haxe.Constraints.IMap<Int,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic inline function set( key : Int, value : T ) : Void {\n\t\tuntyped h[key] = value;\n\t}\n\n\tpublic inline function get( key : Int ) : Null<T> {\n\t\treturn untyped h[key];\n\t}\n\n\tpublic inline function exists( key : Int ) : Bool {\n\t\treturn untyped h.hasOwnProperty(key);\n\t}\n\n\tpublic function remove( key : Int ) : Bool {\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped  __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<Int> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for( var key in {0} ) {1}\", h, if( h.hasOwnProperty(key) ) a.push(key|0));\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of h software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and h permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\npackage haxe.ds;\n\n@:coreApi\nclass ObjectMap<K:{ }, V> implements haxe.Constraints.IMap<K,V> {\n\n\tstatic var count = 0;\n\n\tstatic inline function assignId(obj: { } ):Int {\n\t\treturn untyped obj.__id__ = ++count;\n\t}\n\n\tstatic inline function getId(obj: { } ):Int {\n\t\treturn untyped obj.__id__;\n\t}\n\n\tvar h : { };\n\n\tpublic function new() : Void {\n\t\th = { __keys__: {} };\n\t}\n\n\tpublic function set(key:K, value:V):Void untyped {\n\t\tvar id : Int = getId(key) || assignId(key);\n\t\th[id] = value;\n\t\th.__keys__[id] = key;\n\t}\n\n\tpublic inline function get(key:K):Null<V> {\n\t\treturn untyped h[getId(key)];\n\t}\n\n\tpublic inline function exists(key:K):Bool {\n\t\treturn untyped h.__keys__[getId(key)] != null;\n\t}\n\n\tpublic function remove( key : K ) : Bool {\n\t\tvar id = getId(key);\n\t\tif ( untyped h.__keys__[id] == null ) return false;\n\t\tuntyped  __js__(\"delete\")(h[id]);\n\t\tuntyped  __js__(\"delete\")(h.__keys__[id]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<K> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h.__keys__ ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(h.__keys__[key]);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<V> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[getId(i)]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(Std.string(i));\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n}","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\nprivate class StringMapIterator<T> {\n\tvar map : StringMap<T>;\n\tvar keys : Array<String>;\n\tvar index : Int;\n\tvar count : Int;\n\tpublic inline function new(map:StringMap<T>, keys:Array<String>) {\n\t\tthis.map = map;\n\t\tthis.keys = keys;\n\t\tthis.index = 0;\n\t\tthis.count = keys.length;\n\t}\n\tpublic inline function hasNext() {\n\t\treturn index < count;\n\t}\n\tpublic inline function next() {\n\t\treturn map.get(keys[index++]);\n\t}\n}\n\n@:coreApi class StringMap<T> implements haxe.Constraints.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\tprivate var rh : Dynamic;\n\n\tpublic inline function new() : Void {\n\t\th = {};\n\t}\n\n\tinline function isReserved(key:String) : Bool {\n\t\treturn untyped __js__(\"__map_reserved\")[key] != null;\n\t}\n\n\tpublic inline function set( key : String, value : T ) : Void {\n\t\tif( isReserved(key) )\n\t\t\tsetReserved(key, value);\n\t\telse\n\t\t\th[cast key] = value;\n\t}\n\n\tpublic inline function get( key : String ) : Null<T> {\n\t\tif( isReserved(key) )\n\t\t\treturn getReserved(key);\n\t\treturn h[cast key];\n\t}\n\n\tpublic inline function exists( key : String ) : Bool {\n\t\tif( isReserved(key) )\n\t\t\treturn existsReserved(key);\n\t\treturn h.hasOwnProperty(key);\n\t}\n\n\tfunction setReserved( key : String, value : T ) : Void {\n\t\tif( rh == null ) rh = {};\n\t\trh[cast \"$\"+key] = value;\n\t}\n\n\tfunction getReserved( key : String ) : Null<T> {\n\t\treturn rh == null ? null : rh[cast \"$\"+key];\n\t}\n\n\tfunction existsReserved( key : String ) : Bool {\n\t\tif( rh == null ) return false;\n\t\treturn untyped rh.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tif( isReserved(key) ) {\n\t\t\tkey = \"$\" + key;\n\t\t\tif( rh == null || !rh.hasOwnProperty(key) ) return false;\n\t\t\tuntyped __js__(\"delete\")(rh[key]);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tif( !h.hasOwnProperty(key) )\n\t\t\t\treturn false;\n\t\t\tuntyped __js__(\"delete\")(h[key]);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\treturn arrayKeys().iterator();\n\t}\n\t\n\tfunction arrayKeys() : Array<String> {\n\t\tvar out = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\tout.push(key);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\tif( rh != null ) untyped {\n\t\t\t__js__(\"for( var key in this.rh ) {\");\n\t\t\t\tif( key.charCodeAt(0) == \"$\".code )\n\t\t\t\t\tout.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn out;\n\t}\n\n\tpublic inline function iterator() : Iterator<T> {\n\t\treturn new StringMapIterator(this, arrayKeys());\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar keys = arrayKeys();\n\t\tfor( i in 0...keys.length ) {\n\t\t\tvar k = keys[i];\n\t\t\ts.add(k);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(k)));\n\t\t\tif( i < keys.length-1 )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\tstatic function __init__() : Void {\n\t\tuntyped __js__(\"var __map_reserved = {}\");\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n/**\n\tHelper that converts between floating point and binary representation.\n\tAlways works in low-endian encoding.\n**/\nclass FPHelper {\n\n\t#if neko_v21\n\t// stored in helper\n\t#elseif neko\n\tstatic var i64tmp = new neko.vm.Tls<Int64>();\n\t#elseif !(java || cs)\n\tstatic var i64tmp = Int64.ofInt(0);\n\t#end\n\n\t#if neko\n\t\t#if neko_v21\n\t\tstatic var helpers = new neko.vm.Tls<neko.NativeArray<Dynamic>>();\n\t\t#else\n\t\tstatic var helperf = new neko.vm.Tls<neko.NativeString>();\n\t\tstatic var helperd = new neko.vm.Tls<neko.NativeString>();\n\t\tstatic var _float_of_bytes = neko.Lib.load(\"std\",\"float_of_bytes\",2);\n\t\tstatic var _double_of_bytes = neko.Lib.load(\"std\",\"double_of_bytes\",2);\n\t\tstatic var _float_bytes = neko.Lib.load(\"std\",\"float_bytes\",2);\n\t\tstatic var _double_bytes = neko.Lib.load(\"std\",\"double_bytes\",2);\n\t\t#end\n\t#elseif flash\n\t\tstatic var helper = {\n\t\t\tvar b = new flash.utils.ByteArray();\n\t\t\tb.endian = flash.utils.Endian.LITTLE_ENDIAN;\n\t\t\tb;\n\t\t}\n\t#elseif php\n\t\tstatic var isLittleEndian : Bool = untyped __call__('unpack','S','\\x01\\x00')[1] == 1;\n\t#else\n\t\tstatic inline var LN2 = 0.6931471805599453; // Math.log(2)\n\t#end\n\n\t#if neko_v21 inline #end\n\tpublic static function i32ToFloat( i : Int ) : Float {\n\t\t#if neko\n\t\t\t#if neko_v21\n\t\t\treturn untyped $itof(i,false);\n\t\t\t#else\n\t\t\tvar helper = helperf.value;\n\t\t\tif( helper == null )\n\t\t\t\thelperf.value = helper = neko.NativeString.alloc(4);\n\t\t\tuntyped $sset(helper,0,i&0xFF);\n\t\t\tuntyped $sset(helper,1,(i>>8)&0xFF);\n\t\t\tuntyped $sset(helper,2,(i>>16)&0xFF);\n\t\t\tuntyped $sset(helper,3,i>>>24);\n\t\t\treturn _float_of_bytes(helper,false);\n\t\t\t#end\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32_as_float32(i);\n\t\t#elseif cs\n\t\t\tvar helper = new SingleHelper(0);\n\t\t\tif( cs.system.BitConverter.IsLittleEndian )\n\t\t\t{\n\t\t\t\thelper.i = i;\n\t\t\t} else {\n\t\t\t\thelper.i = ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t\t}\n\n\t\t\treturn helper.f;\n\t\t#elseif java\n\t\t\treturn java.lang.Float.FloatClass.intBitsToFloat(i);\n\t\t#elseif php\n\t\t\treturn untyped  __call__('unpack', 'f', __call__('pack', 'l', i))[1];\n\t\t#elseif flash\n\t\t\tvar helper = helper;\n\t\t\thelper.position = 0;\n\t\t\thelper.writeUnsignedInt(i);\n\t\t\thelper.position = 0;\n\t\t\treturn helper.readFloat();\n\t\t#else\n\t\t\tvar sign = 1 - ((i >>> 31) << 1);\n\t\t\tvar exp = (i >>> 23) & 0xFF;\n\t\t\tvar sig = i & 0x7FFFFF;\n\t\t\tif( sig == 0 && exp == 0 )\n\t\t\t\treturn 0.0;\n\t\t\treturn sign*(1 + Math.pow(2, -23)*sig) * Math.pow(2, exp-127);\n\t\t#end\n\t}\n\n\t#if neko_v21 inline #end\n\tpublic static function floatToI32( f : Float ) : Int {\n\t\t#if neko\n\t\t\t#if neko_v21\n\t\t\treturn untyped $ftoi(f,false);\n\t\t\t#else\n\t\t\tvar r = _float_bytes(f,false);\n\t\t\treturn untyped $sget(r,0) | ($sget(r,1)<<8) | ($sget(r,2)<<16) | ($sget(r,3)<<24);\n\t\t\t#end\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__hxcpp_reinterpret_float32_as_le_int32(f);\n\t\t#elseif cs\n\t\t\tvar helper = new SingleHelper(f);\n\t\t\tif( cs.system.BitConverter.IsLittleEndian )\n\t\t\t{\n\t\t\t\treturn helper.i;\n\t\t\t} else {\n\t\t\t\tvar i = helper.i;\n\t\t\t\treturn ((i >>> 24) & 0xFF) | (((i >> 16) & 0xFF) << 8) | (((i >> 8) & 0xFF) << 16) | ((i & 0xFF) << 24);\n\t\t\t}\n\t\t#elseif java\n\t\t\treturn java.lang.Float.FloatClass.floatToRawIntBits(f);\n\t\t#elseif flash\n\t\t\tvar helper = helper;\n\t\t\thelper.position = 0;\n\t\t\thelper.writeFloat(f);\n\t\t\thelper.position = 0;\n\t\t\treturn helper.readUnsignedInt();\n\t\t#elseif php\n\t\t\treturn untyped __call__('unpack','l',__call__('pack', 'f', f))[1];\n\t\t#else\n\t\t\tif( f == 0 ) return 0;\n\t\t\tvar af = f < 0 ? -f : f;\n\t\t\tvar exp = Math.floor(Math.log(af) / LN2);\n\t\t\tif( exp < -127 ) exp = -127 else if( exp > 128 ) exp = 128;\n\t\t\tvar sig = Math.round((af / Math.pow(2, exp) - 1) * 0x800000);\n\t\t\tif( sig == 0x800000 && exp < 128 ){\n\t\t\t\tsig = 0;\n\t\t\t\texp++;\n\t\t\t}\n\t\t\treturn (f < 0 ? 0x80000000 : 0) | ((exp + 127) << 23) | sig;\n\t\t#end\n\t}\n\n\t#if neko_v21 inline #end\n\tpublic static function i64ToDouble( low : Int, high : Int ) : Float {\n\t\t#if neko\n\t\t\t#if neko_v21\n\t\t\treturn untyped $itod(low,high,false);\n\t\t\t#else\n\t\t\tvar helper = helperd.value;\n\t\t\tif( helper == null )\n\t\t\t\thelperd.value = helper = neko.NativeString.alloc(8);\n\t\t\tuntyped $sset(helper,0,low&0xFF);\n\t\t\tuntyped $sset(helper,1,(low>>8)&0xFF);\n\t\t\tuntyped $sset(helper,2,(low>>16)&0xFF);\n\t\t\tuntyped $sset(helper,3,low>>>24);\n\t\t\tuntyped $sset(helper,4,high&0xFF);\n\t\t\tuntyped $sset(helper,5,(high>>8)&0xFF);\n\t\t\tuntyped $sset(helper,6,(high>>16)&0xFF);\n\t\t\tuntyped $sset(helper,7,high>>>24);\n\t\t\treturn _double_of_bytes(helper,false);\n\t\t\t#end\n\t\t#elseif cpp\n\t\t\treturn untyped __global__.__hxcpp_reinterpret_le_int32s_as_float64(low,high);\n\t\t#elseif cs\n\t\t\tvar helper = new FloatHelper(0);\n\t\t\tif( cs.system.BitConverter.IsLittleEndian )\n\t\t\t{\n\t\t\t\thelper.i = haxe.Int64.make(high,low);\n\t\t\t} else {\n\t\t\t\tvar i1 = high,\n\t\t\t\t    i2 = low;\n\t\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\t\t\t\thelper.i = haxe.Int64.make(j1,j2);\n\t\t\t}\n\t\t\treturn helper.f;\n\t\t#elseif java\n\t\t\treturn java.lang.Double.DoubleClass.longBitsToDouble( Int64.make(high,low) );\n\t\t#elseif flash\n\t\t\tvar helper = helper;\n\t\t\thelper.position = 0;\n\t\t\thelper.writeUnsignedInt(low);\n\t\t\thelper.writeUnsignedInt(high);\n\t\t\thelper.position = 0;\n\t\t\treturn helper.readDouble();\n\t\t#elseif php\n\t\t\treturn untyped  __call__('unpack', 'd', __call__('pack', 'ii', isLittleEndian ? low : high, isLittleEndian ? high : low))[1];\n\t\t#else\n\t\t\t#if python\n\t\t\tif (low == 0 && high == 2146435072) {\n\t\t\t\treturn Math.POSITIVE_INFINITY;\n\t\t\t} else if (low == 0 && high == -1048576 ) {\n\t\t\t\treturn Math.NEGATIVE_INFINITY;\n\t\t\t}\n\t\t\t#end\n\t\t\tvar sign = 1 - ((high >>> 31) << 1);\n\t\t\tvar exp = ((high >> 20) & 0x7FF) - 1023;\n\t\t\tvar sig = (high&0xFFFFF) * 4294967296. + (low>>>31) * 2147483648. + (low&0x7FFFFFFF);\n\t\t\tif( sig == 0 && exp == -1023 )\n\t\t\t\treturn 0.0;\n\t\t\treturn sign*(1.0 + Math.pow(2, -52)*sig) * Math.pow(2, exp);\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns an Int64 representing the bytes representation of the double precision IEEE float value.\n\t\tWARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.\n\t\tWe still ensure that this is safe to use in a multithread environment\n\t**/\n\tpublic static function doubleToI64( v : Float ) : Int64 {\n\t\t#if neko\n\t\t\t#if neko_v21\n\t\t\tvar helper = helpers.value;\n\t\t\tif( helper == null ) {\n\t\t\t\thelpers.value = helper = neko.NativeArray.alloc(2);\n\t\t\t\thelper[0] = neko.NativeArray.alloc(2);\n\t\t\t\thelper[1] = haxe.Int64.ofInt(0);\n\t\t\t}\n\t\t\tvar i64 : haxe.Int64 = helper[1], int2 = helper[0];\n\t\t\tuntyped $dtoi(v,int2,false);\n\t\t\t@:privateAccess {\n\t\t\t\ti64.set_low(int2[0]);\n\t\t\t\ti64.set_high(int2[1]);\n\t\t\t}\n\t\t\treturn i64;\n\t\t\t#else\n\t\t\tvar r = _double_bytes(v,false), i64 = i64tmp.value;\n\t\t\tif( i64 == null )\n\t\t\t\ti64 = i64tmp.value = haxe.Int64.ofInt(0);\n\t\t\t@:privateAccess {\n\t\t\t\ti64.set_low(untyped $sget(r,0) | ($sget(r,1)<<8) | ($sget(r,2)<<16) | ($sget(r,3)<<24));\n\t\t\t\ti64.set_high(untyped $sget(r,4) | ($sget(r,5)<<8) | ($sget(r,6)<<16) | ($sget(r,7)<<24));\n\t\t\t}\n\t\t\treturn i64;\n\t\t\t#end\n\t\t#elseif cpp\n\t\t\treturn Int64.make(untyped __global__.__hxcpp_reinterpret_float64_as_le_int32_high(v),\n\t\t\t\t               untyped __global__.__hxcpp_reinterpret_float64_as_le_int32_low(v) );\n\t\t#elseif java\n\t\t\treturn java.lang.Double.DoubleClass.doubleToRawLongBits(v);\n\t\t#elseif cs\n\t\t\tvar helper = new FloatHelper(v);\n\t\t\tif( cs.system.BitConverter.IsLittleEndian )\n\t\t\t{\n\t\t\t\treturn helper.i;\n\t\t\t} else {\n\t\t\t\tvar i = helper.i;\n\t\t\t\tvar i1 = haxe.Int64.getHigh(i),\n\t\t\t\t    i2 = haxe.Int64.getLow(i);\n\t\t\t\tvar j2 = ((i1 >>> 24) & 0xFF) | (((i1 >> 16) & 0xFF) << 8) | (((i1 >> 8) & 0xFF) << 16) | ((i1 & 0xFF) << 24);\n\t\t\t\tvar j1 = ((i2 >>> 24) & 0xFF) | (((i2 >> 16) & 0xFF) << 8) | (((i2 >> 8) & 0xFF) << 16) | ((i2 & 0xFF) << 24);\n\n\t\t\t\treturn haxe.Int64.make(j1,j2);\n\t\t\t}\n\t\t#elseif flash\n\t\t\tvar helper = helper;\n\t\t\thelper.position = 0;\n\t\t\thelper.writeDouble(v);\n\t\t\thelper.position = 0;\n\t\t\tvar i64 = i64tmp;\n\t\t\t@:privateAccess {\n\t\t\t\ti64.set_low(cast helper.readUnsignedInt());\n\t\t\t\ti64.set_high(cast helper.readUnsignedInt());\n\t\t\t}\n\t\t\treturn i64;\n\t\t#elseif php\n\t\t\tvar a = untyped __call__('unpack',isLittleEndian ? 'V2' : 'N2',__call__('pack', 'd', v));\n\t\t\tvar i64 = i64tmp;\n\t\t\t@:privateAccess {\n\t\t\t\ti64.set_low(a[isLittleEndian ? 1 : 2]);\n\t\t\t\ti64.set_high(a[isLittleEndian ? 2 : 1]);\n\t\t\t}\n\t\t\treturn i64;\n\t\t#else\n\t\t\tvar i64 = i64tmp;\n\t\t\tif( v == 0 ) {\n\t\t\t\t@:privateAccess {\n\t\t\t\t\ti64.set_low(0);\n\t\t\t\t\ti64.set_high(0);\n\t\t\t\t}\n\t\t\t} else if (!Math.isFinite(v)) @:privateAccess {\n\t\t\t\tif (v > 0) {\n\t\t\t\t\ti64.set_low(0);\n\t\t\t\t\ti64.set_high(2146435072);\n\t\t\t\t} else {\n\t\t\t\t\ti64.set_low(0);\n\t\t\t\t\ti64.set_high(-1048576);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar av = v < 0 ? -v : v;\n\t\t\t\tvar exp = Math.floor(Math.log(av) / LN2);\n\t\t\t\tvar sig = Math.fround(((av / Math.pow(2, exp)) - 1) * 4503599627370496.); // 2^52\n\t\t\t\tvar sig_l = Std.int(sig);\n\t\t\t\tvar sig_h = Std.int(sig / 4294967296.0);\n\t\t\t\t@:privateAccess {\n\t\t\t\t\ti64.set_low(sig_l);\n\t\t\t\t\ti64.set_high((v < 0 ? 0x80000000 : 0) | ((exp + 1023) << 20) | sig_h);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i64;\n\t\t#end\n\t}\n\n}\n\n#if cs\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class SingleHelper\n{\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:Int;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Single;\n\n\tpublic function new(f:Single)\n\t{\n\t\tthis.i = 0;\n\t\tthis.f = f;\n\t}\n}\n\n@:meta(System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit))\n@:nativeGen @:struct private class FloatHelper\n{\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var i:haxe.Int64;\n\t@:meta(System.Runtime.InteropServices.FieldOffset(0))\n\tpublic var f:Float;\n\n\tpublic function new(f:Float)\n\t{\n\t\tthis.i = haxe.Int64.ofInt(0);\n\t\tthis.f = f;\n\t}\n}\n\n#end\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\n#if !nodejs\nimport js.html.compat.Float32Array;\n#end\n\ntypedef Float32ArrayData = js.html.Float32Array;\n\n@:coreApi\nabstract Float32Array(Float32ArrayData) {\n\n\tpublic static inline var BYTES_PER_ELEMENT = 4;\n\tpublic var length(get,never) : Int;\n\tpublic var view(get,never) : ArrayBufferView;\n\n\tpublic inline function new( elements : Int ) : Void {\n\t\tthis = new Float32ArrayData(elements);\n\t}\n\n\tinline function get_length() : Int {\n\t\treturn this.length;\n\t}\n\n\tpublic inline function get_view() : ArrayBufferView {\n\t\treturn ArrayBufferView.fromData(this);\n\t}\n\n\t@:arrayAccess public inline function get( index : Int ) : Float {\n\t\treturn this[index];\n\t}\n\n\t@:arrayAccess public inline function set( index : Int, value : Float ) : Float {\n\t\treturn this[index] = value;\n\t}\n\n\tpublic inline function sub( begin : Int, ?length : Int ) : Float32Array {\n\t\treturn fromData(this.subarray(begin, length == null ? this.length : begin+length));\n\t}\n\n\tpublic inline function subarray( ?begin : Int, ?end : Int ) : Float32Array {\n\t\treturn fromData(this.subarray(begin, end));\n\t}\n\n\tpublic inline function getData() : Float32ArrayData {\n\t\treturn this;\n\t}\n\n\tpublic inline static function fromData( d : Float32ArrayData ) : Float32Array {\n\t\treturn cast d;\n\t}\n\n\tpublic static function fromArray( a : Array<Float>, pos : Int = 0, ?length : Int ) : Float32Array {\n\t\tif( length == null ) length = a.length - pos;\n\t\tif( pos < 0 || length < 0 || pos + length > a.length ) throw Error.OutsideBounds;\n\t\tif( pos == 0 && length == a.length )\n\t\t\treturn fromData(new Float32ArrayData(a));\n\t\tvar i = new Float32Array(a.length);\n\t\tfor( idx in 0...length )\n\t\t\ti[idx] = a[idx + pos];\n\t\treturn i;\n\t}\n\n\tpublic static function fromBytes( bytes : haxe.io.Bytes, bytePos : Int = 0, ?length : Int ) : Float32Array {\n\t\tif( length == null ) length = (bytes.length - bytePos) >> 2;\n\t\treturn fromData(new Float32ArrayData(bytes.getData(), bytePos, length));\n\t}\n}\n\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.io;\n\ntypedef Int32ArrayData = js.html.Int32Array;\n\n@:coreApi\nabstract Int32Array(Int32ArrayData) {\n\n\tpublic static inline var BYTES_PER_ELEMENT = 1;\n\tpublic var length(get,never) : Int;\n\tpublic var view(get,never) : ArrayBufferView;\n\n\tpublic inline function new( elements : Int ) {\n\t\tthis = new Int32ArrayData(elements * BYTES_PER_ELEMENT);\n\t}\n\n\tinline function get_length() : Int {\n\t\treturn this.length;\n\t}\n\n\tpublic inline function get_view() : ArrayBufferView {\n\t\treturn ArrayBufferView.fromData(this);\n\t}\n\n\t@:arrayAccess public inline function get( index : Int ) : Int {\n\t\treturn this[index];\n\t}\n\n\t@:arrayAccess public inline function set( index : Int, value : Int ) : Int {\n\t\treturn this[index] = value | 0; // necessary for html compat\n\t}\n\n\tpublic inline function sub( begin : Int, ?length : Int ) : Int32Array {\n\t\treturn fromData(this.subarray(begin, length == null ? this.length : begin+length));\n\t}\n\n\tpublic inline function subarray( ?begin : Int, ?end : Int ) : Int32Array {\n\t\treturn fromData(this.subarray(begin, end));\n\t}\n\n\tpublic inline function getData() : Int32ArrayData {\n\t\treturn this;\n\t}\n\n\tpublic static inline function fromData( d : Int32ArrayData ) : Int32Array {\n\t\treturn cast d;\n\t}\n\n\tpublic static function fromArray( a : Array<Int>, pos : Int = 0, ?length : Int ) : Int32Array {\n\t\tif( length == null ) length = a.length - pos;\n\t\tif( pos < 0 || length < 0 || pos + length > a.length ) throw Error.OutsideBounds;\n\t\tif( pos == 0 && length == a.length )\n\t\t\treturn fromData(new Int32ArrayData(a));\n\t\tvar i = new Int32Array(a.length);\n\t\tfor( idx in 0...length )\n\t\t\ti[idx] = a[idx + pos];\n\t\treturn i;\n\t}\n\n\tpublic static function fromBytes( bytes : haxe.io.Bytes, bytePos : Int = 0, ?length : Int ) : Int32Array {\n\t\tif( length == null ) length = (bytes.length - bytePos) >> 2;\n\t\treturn fromData(new Int32ArrayData(bytes.getData(), bytePos, length));\n\t}\n\n}\n\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nprivate class HaxeError extends js.Error {\n\n\tvar val:Dynamic;\n\n\tpublic function new(val:Dynamic) untyped {\n\t\tsuper();\n\t\tthis.val = __define_feature__(\"js.Boot.HaxeError\", val);\n\t\tthis.message = String(val);\n\t\tif (js.Error.captureStackTrace) js.Error.captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):Dynamic untyped {\n\t\treturn if (__instanceof__(val, js.Error)) val else new HaxeError(val);\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && __typeof__(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\" && untyped __js__(\"(o|0) === o\");\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( (untyped __js__(\"typeof\"))(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr = untyped ({}).toString;\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name = untyped __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn untyped js.Lib.global[name];\n\t}\n\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n// This file is generated from mozilla\\HTMLCanvasElement.webidl. Do not edit!\n\npackage js.html;\n\n/**\n\tThe `HTMLCanvasElement` interface provides properties and methods for manipulating the layout and presentation of canvas elements. The `HTMLCanvasElement` interface also inherits the properties and methods of the `HTMLElement` interface.\n\n\tDocumentation [HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement) by [Mozilla Contributors](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement$history), licensed under [CC-BY-SA 2.5](https://creativecommons.org/licenses/by-sa/2.5/).\n\n\t@see <https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement>\n**/\n@:native(\"HTMLCanvasElement\")\nextern class CanvasElement extends Element\n{\n\t\n\t/**\n\t\tIs a positive `integer` reflecting the `width` HTML attribute of the `canvas` element interpreted in CSS pixels. When the attribute is not specified, or if it is set to an invalid value, like a negative, the default value of `300` is used.\n\t**/\n\tvar width : Int;\n\t\n\t/**\n\t\tIs a positive `integer` reflecting the `height` HTML attribute of the `canvas` element interpreted in CSS pixels. When the attribute is not specified, or if it is set to an invalid value, like a negative, the default value of `150` is used.\n\t**/\n\tvar height : Int;\n\t\n\t/** @throws DOMError */\n\t\n\t/**\n\t\tReturns a drawing context on the canvas, or null if the context ID is not supported. A drawing context lets you draw on the canvas. Calling getContext with `\"2d\"` returns a `CanvasRenderingContext2D` object, whereas calling it with `\"experimental-webgl\"` (or `\"webgl\"`) returns a `WebGLRenderingContext` object. This context is only available on browsers that implement WebGL.\n\t**/\n\tfunction getContext( contextId : String, ?contextOptions : Dynamic ) : Dynamic/*MISSING nsISupports*/;\n\t/** @throws DOMError */\n\t\n\t/**\n\t\tReturns a data-URL containing a representation of the image in the format specified by the `type` parameter (defaults to `png`). The returned image is in a resolution of 96dpi.\n\t**/\n\tfunction toDataURL( ?type : String = \"\", ?encoderOptions : Dynamic ) : String;\n\t/** @throws DOMError */\n\t\n\t/**\n\t\tCreates a `Blob` object representing the image contained in the canvas; this file may be cached on the disk or stored in memory at the discretion of the user agent.\n\t**/\n\tfunction toBlob( callback : Blob -> Void, ?type : String = \"\", ?encoderOptions : Dynamic ) : Void;\n\t\n\t/** Shorthand for getting a CanvasRenderingContext2D. */\n\tinline function getContext2d( ?attribs : {} ) : CanvasRenderingContext2D {\n\t\treturn cast getContext(\"2d\", attribs);\n\t}\n\t/** Shorthand for getting a js.html.webgl.RenderingContext. */\n\tinline function getContextWebGL( ?attribs : js.html.webgl.ContextAttributes ) : js.html.webgl.RenderingContext {\n\t\treturn CanvasUtil.getContextWebGL(this, attribs);\n\t}\n}\n\nprivate class CanvasUtil {\n\tpublic static function getContextWebGL( canvas :CanvasElement, attribs :{} ) {\n\t\tfor (name in [\"webgl\", \"experimental-webgl\"]) {\n\t\t\tvar ctx = canvas.getContext(name, attribs);\n\t\t\tif (ctx != null) return ctx;\n\t\t}\n\t\treturn null;\n\t}\n}\n","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js.html.compat;\n\n#if !nodejs\n@:ifFeature(\"js.html.ArrayBuffer.*\")\nclass ArrayBuffer {\n\n\tpublic var byteLength : Int;\n\tvar a : Array<Int>;\n\n\tpublic function new( ?a : Dynamic ) {\n\t\tif( Std.is(a,Array) ) {\n\t\t\tthis.a = a;\n\t\t\tbyteLength = a.length;\n\t\t} else {\n\t\t\tvar len : Int = a;\n\t\t\tthis.a = [];\n\t\t\tfor( i in 0...len )\n\t\t\t\tthis.a[i] = 0;\n\t\t\tbyteLength = len;\n\t\t}\n\t}\n\n\tpublic function slice(begin,?end) {\n\t\treturn new ArrayBuffer(a.slice(begin,end));\n\t}\n\n\tstatic function sliceImpl(begin,?end) {\n\t\tvar u = new js.html.Uint8Array(js.Lib.nativeThis, begin, end == null ? null : end - begin);\n\t\tvar result = new js.html.ArrayBuffer(u.byteLength);\n\t\tvar resultArray = new js.html.Uint8Array(result);\n\t\tresultArray.set(u);\n\t\treturn result;\n\t}\n\n\tstatic function __init__() untyped {\n\t\tvar ArrayBuffer = js.Lib.global.ArrayBuffer || js.html.compat.ArrayBuffer;\n\t\tif( ArrayBuffer.prototype.slice == null ) ArrayBuffer.prototype.slice = sliceImpl; // IE10\n\t}\n}\n#end","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js.html.compat;\n\n#if !nodejs\nimport haxe.io.Error;\n\n@:ifFeature(\"js.html.DataView.*\")\n@:access(js.html.compat.ArrayBuffer)\nclass DataView {\n\n\tvar buf : ArrayBuffer;\n\tvar offset : Int;\n\tvar length : Int;\n\n\tpublic var byteLength(default,null):Int;\n\tpublic var byteOffset(default,null):Int;\n\tpublic var buffer(default,null):ArrayBuffer;\n\n\tpublic function new( buffer : ArrayBuffer, ?byteOffset : Int, ?byteLength : Int ) : Void {\n\t\tthis.buf = buffer;\n\t\tthis.offset = byteOffset == null ? 0 : byteOffset;\n\t\tthis.length = byteLength == null ? buffer.byteLength - this.offset : byteLength;\n\t\tif( offset < 0 || length < 0 || offset+length > buffer.byteLength )\n\t\t\tthrow OutsideBounds;\n\t\tthis.byteLength = length;\n\t\tthis.byteOffset = offset;\n\t\tthis.buffer = buf;\n\t}\n\n\tpublic function getInt8( byteOffset : Int ) : Int {\n\t\tvar v = buf.a[offset + byteOffset];\n\t\treturn v >= 0x80 ? v - 256 : v;\n\t}\n\n\tpublic function getUint8( byteOffset : Int ) : Int {\n\t\treturn buf.a[offset + byteOffset];\n\t}\n\n\tpublic function getInt16( byteOffset : Int, ?littleEndian : Bool ) : Int {\n\t\tvar v = getUint16(byteOffset, littleEndian);\n\t\treturn v >= 0x8000 ? v - 65536 : v;\n\t}\n\n\tpublic function getUint16( byteOffset : Int, ?littleEndian : Bool ) : Int {\n\t\treturn littleEndian ? buf.a[offset + byteOffset] | (buf.a[offset + byteOffset + 1] << 8) : (buf.a[offset + byteOffset]<<8) | buf.a[offset + byteOffset + 1];\n\t}\n\n\tpublic function getInt32( byteOffset : Int, ?littleEndian : Bool ) : Int {\n\t\tvar p = offset + byteOffset;\n\t\tvar a = buf.a[p++];\n\t\tvar b = buf.a[p++];\n\t\tvar c = buf.a[p++];\n\t\tvar d = buf.a[p++];\n\t\treturn littleEndian ? a | (b<<8) | (c<<16) | (d<<24) : d | (c << 8) | (b << 16) | (a << 24);\n\t}\n\n\tpublic function getUint32( byteOffset : Int, ?littleEndian : Bool ) : Int {\n\t\tvar v = getInt32(byteOffset, littleEndian);\n\t\treturn v < 0 ? cast (v + 4294967296.) : v;\n\t}\n\n\tpublic function getFloat32( byteOffset : Int, ?littleEndian : Bool ) : Float {\n\t\treturn haxe.io.FPHelper.i32ToFloat(getInt32(byteOffset,littleEndian));\n\t}\n\n\tpublic function getFloat64( byteOffset : Int, ?littleEndian : Bool ) : Float {\n\t\tvar a = getInt32(byteOffset, littleEndian);\n\t\tvar b = getInt32(byteOffset + 4, littleEndian);\n\t\treturn haxe.io.FPHelper.i64ToDouble(littleEndian?a:b,littleEndian?b:a);\n\t}\n\n\tpublic function setInt8( byteOffset : Int, value : Int ) : Void {\n\t\tbuf.a[byteOffset + offset] = (value < 0) ? (value + 128) & 0xFF : value & 0xFF;\n\t}\n\n\tpublic function setUint8( byteOffset : Int, value : Int ) : Void {\n\t\tbuf.a[byteOffset + offset] = value & 0xFF;\n\t}\n\n\tpublic function setInt16( byteOffset : Int, value : Int, ?littleEndian : Bool ) : Void {\n\t\tsetUint16(byteOffset, value < 0 ? value + 65536 : value, littleEndian);\n\t}\n\n\tpublic function setUint16( byteOffset : Int, value : Int, ?littleEndian : Bool ) : Void {\n\t\tvar p = byteOffset + offset;\n\t\tif( littleEndian ) {\n\t\t\tbuf.a[p] = value&0xFF;\n\t\t\tbuf.a[p++] = (value>>8) & 0xFF;\n\t\t} else {\n\t\t\tbuf.a[p++] = (value>>8) & 0xFF;\n\t\t\tbuf.a[p] = value&0xFF;\n\t\t}\n\t}\n\n\tpublic function setInt32( byteOffset : Int, value : Int, ?littleEndian : Bool ) : Void {\n\t\tsetUint32(byteOffset, value, littleEndian);\n\t}\n\n\tpublic function setUint32( byteOffset : Int, value : Int, ?littleEndian : Bool ) : Void {\n\t\tvar p = byteOffset + offset;\n\t\tif( littleEndian ) {\n\t\t\tbuf.a[p++] = value & 0xFF;\n\t\t\tbuf.a[p++] = (value>>8) & 0xFF;\n\t\t\tbuf.a[p++] = (value>>16) & 0xFF;\n\t\t\tbuf.a[p++] = value >>> 24;\n\t\t} else {\n\t\t\tbuf.a[p++] = value >>> 24;\n\t\t\tbuf.a[p++] = (value>>16) & 0xFF;\n\t\t\tbuf.a[p++] = (value>>8) & 0xFF;\n\t\t\tbuf.a[p++] = value & 0xFF;\n\t\t}\n\t}\n\n\tpublic function setFloat32( byteOffset : Int, value : Float, ?littleEndian : Bool ) : Void {\n\t\tsetUint32(byteOffset, haxe.io.FPHelper.floatToI32(value),littleEndian);\n\t}\n\n\tpublic function setFloat64( byteOffset : Int, value : Float, ?littleEndian : Bool ) : Void {\n\t\tvar i64 = haxe.io.FPHelper.doubleToI64(value);\n\t\tif( littleEndian ) {\n\t\t\tsetUint32(byteOffset, i64.low);\n\t\t\tsetUint32(byteOffset, i64.high);\n\t\t} else {\n\t\t\tsetUint32(byteOffset, i64.high);\n\t\t\tsetUint32(byteOffset, i64.low);\n\t\t}\n\t}\n\n\tstatic function __init__() {\n\t\tvar DataView = untyped js.Lib.global.DataView || js.html.compat.DataView;\n\t}\n\n}\n#end","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js.html.compat;\n\n#if !nodejs\nimport js.Lib.nativeThis;\n\n@:ifFeature(\"js.html.Float32Array.*\")\nclass Float32Array {\n\n\tstatic var BYTES_PER_ELEMENT = 4;\n\n\tstatic function _new( ?arg1 : Dynamic, ?offset : Int, ?length : Int ) : Dynamic {\n\t\tvar arr : Array<Float>;\n\t\tif( untyped __typeof__(arg1) == 'number' ) {\n\t\t\tarr = new Array();\n\t\t\tfor( i in 0...arg1 )\n\t\t\t\tarr[i] = 0;\n\t\t\tuntyped {\n\t\t\t\tarr.byteLength = arr.length << 2;\n\t\t\t\tarr.byteOffset = 0;\n\t\t\t\tarr.buffer = new ArrayBuffer([for( i in 0...arr.length << 2 ) 0]); // no sync\n\t\t\t}\n\t\t} else if( Std.is(arg1,ArrayBuffer) ) {\n\t\t\tvar buffer : ArrayBuffer = arg1;\n\t\t\tif( offset == null ) offset = 0;\n\t\t\tif( length == null ) length = (buffer.byteLength - offset) >> 2;\n\t\t\tarr = [];\n\t\t\t// decode buffer\n\t\t\tfor( i in 0...length ) {\n\t\t\t\tvar val = untyped buffer.a[offset++] | (buffer.a[offset++] << 8) | (buffer.a[offset++] << 16) | (buffer.a[offset++] << 24);\n\t\t\t\tarr.push(haxe.io.FPHelper.i32ToFloat(val));\n\t\t\t}\n\t\t\tuntyped {\n\t\t\t\tarr.byteLength = arr.length<<2;\n\t\t\t\tarr.byteOffset = offset;\n\t\t\t\tarr.buffer = buffer;\n\t\t\t}\n\t\t} else if( Std.is(arg1, Array) ) {\n\t\t\tarr = (arg1 : Array<Float>).copy();\n\t\t\t// loss of memory sync between buffer and array\n\t\t\tvar buffer = [];\n\t\t\tfor( f in arr ) {\n\t\t\t\tvar i = haxe.io.FPHelper.floatToI32(f);\n\t\t\t\tbuffer.push(i&0xFF);\n\t\t\t\tbuffer.push((i>>8)&0xFF);\n\t\t\t\tbuffer.push((i>>16)&0xFF);\n\t\t\t\tbuffer.push(i>>>24);\n\t\t\t}\n\t\t\tuntyped {\n\t\t\t\tarr.byteLength = arr.length << 2;\n\t\t\t\tarr.byteOffset = 0;\n\t\t\t\tarr.buffer = new ArrayBuffer(buffer);\n\t\t\t}\n\t\t} else\n\t\t\tthrow \"TODO \"+arg1;\n\t\tuntyped {\n\t\t\tarr.subarray = _subarray;\n\t\t\tarr.set = _set;\n\t\t}\n\t\treturn arr;\n\t}\n\n\tstatic function _set( ?arg : Dynamic, ?offset : Int ) {\n\t\tif( Std.is(arg.buffer,ArrayBuffer) ) {\n\t\t\tvar a : Array<Int> = arg;\n\t\t\tif( arg.byteLength + offset > nativeThis.byteLength )\n\t\t\t\tthrow \"set() outside of range\";\n\t\t\tfor( i in 0...arg.byteLength )\n\t\t\t\tnativeThis[i + offset] = a[i];\n\t\t} else if( Std.is(arg,Array) ) {\n\t\t\tvar a : Array<Int> = arg;\n\t\t\tif( a.length + offset > nativeThis.byteLength )\n\t\t\t\tthrow \"set() outside of range\";\n\t\t\tfor( i in 0...a.length )\n\t\t\t\tnativeThis[i + offset] = a[i];\n\t\t} else\n\t\t\tthrow \"TODO\";\n\t}\n\n\tstatic function _subarray( start : Int, ?end : Int ) {\n\t\tvar a = _new(nativeThis.slice(start,end));\n\t\ta.byteOffset = start * 4;\n\t\treturn a;\n\t}\n\n\tstatic function __init__() {\n\t\tvar Float32Array = untyped js.Lib.global.Float32Array || _new;\n\t}\n\n}\n#end","/*\n * Copyright (C)2005-2017 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js.html.compat;\n\n#if !nodejs\nimport js.Lib.nativeThis;\n\n@:ifFeature(\"js.html.Uint8Array.*\")\nclass Uint8Array {\n\n\tstatic var BYTES_PER_ELEMENT = 1;\n\n\tstatic function _new( ?arg1 : Dynamic, ?offset : Int, ?length : Int ) : Dynamic {\n\t\tvar arr;\n\t\tif( untyped __typeof__(arg1) == 'number' ) {\n\t\t\tarr = new Array();\n\t\t\tfor( i in 0...arg1 )\n\t\t\t\tarr[i] = 0;\n\t\t\tuntyped {\n\t\t\t\tarr.byteLength = arr.length;\n\t\t\t\tarr.byteOffset = 0;\n\t\t\t\tarr.buffer = new ArrayBuffer(arr);\n\t\t\t}\n\t\t} else if( Std.is(arg1,ArrayBuffer) ) {\n\t\t\tvar buffer : ArrayBuffer = arg1;\n\t\t\tif( offset == null ) offset = 0;\n\t\t\tif( length == null ) length = buffer.byteLength - offset;\n\t\t\tif( offset == 0 )\n\t\t\t\tarr = cast @:privateAccess buffer.a;\n\t\t\telse\n\t\t\t\t// here we are losing the fact that we should reference the same data,\n\t\t\t\t// but I don't see another way to have this behaviour while keeping [] access\n\t\t\t\tarr = cast @:privateAccess buffer.a.slice(offset, offset+length);\n\t\t\tuntyped {\n\t\t\t\tarr.byteLength = arr.length;\n\t\t\t\tarr.byteOffset = offset;\n\t\t\t\tarr.buffer = buffer;\n\t\t\t}\n\t\t} else if( Std.is(arg1, Array) ) {\n\t\t\tarr = (arg1 : Array<Int>).copy();\n\t\t\tuntyped {\n\t\t\t\tarr.byteLength = arr.length;\n\t\t\t\tarr.byteOffset = 0;\n\t\t\t\tarr.buffer = new ArrayBuffer(arr);\n\t\t\t}\n\t\t} else\n\t\t\tthrow \"TODO \"+arg1;\n\t\tuntyped {\n\t\t\tarr.subarray = _subarray;\n\t\t\tarr.set = _set;\n\t\t}\n\t\treturn arr;\n\t}\n\n\tstatic function _set( ?arg : Dynamic, ?offset : Int ) {\n\t\tif( Std.is(arg.buffer,ArrayBuffer) ) {\n\t\t\tvar a : Array<Int> = arg;\n\t\t\tif( arg.byteLength + offset > nativeThis.byteLength )\n\t\t\t\tthrow \"set() outside of range\";\n\t\t\tfor( i in 0...arg.byteLength )\n\t\t\t\tnativeThis[i + offset] = a[i];\n\t\t} else if( Std.is(arg,Array) ) {\n\t\t\tvar a : Array<Int> = arg;\n\t\t\tif( a.length + offset > nativeThis.byteLength )\n\t\t\t\tthrow \"set() outside of range\";\n\t\t\tfor( i in 0...a.length )\n\t\t\t\tnativeThis[i + offset] = a[i];\n\t\t} else\n\t\t\tthrow \"TODO\";\n\t}\n\n\tstatic function _subarray( start : Int, ?end : Int ) {\n\t\tvar a = _new(nativeThis.slice(start,end));\n\t\ta.byteOffset = start;\n\t\treturn a;\n\t}\n\n\tstatic function __init__() {\n\t\tvar Uint8Array = untyped js.Lib.global.Uint8Array || _new;\n\t}\n\n}\n#end","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth;\n\nimport haxe.io.Path;\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.EnumFlags;\n\n/**\n * Generally not used by user-facing code, this `enum` is for tracking\n * the type of log that is being written.\n */\nenum LogFunctions {\n\t/**\n\t * Show-stopping error\n\t */\n\tFatal;\n\n\t/**\n\t * Crashes / exceptions\n\t */\n\tError;\n\n\t/**\n\t * Incorrect behaviour but can continue\n\t */\n\tWarn;\n\n\t/**\n\t * Indicates correct behaviour\n\t */\n\tInfo;\n\n\t/**\n\t * Behind-the-scenes poking around\n\t */\n\tDebug;\n}\n\nclass Log {\n    private function new() {}\n\n\tpublic static function log(v:Dynamic, func:LogFunctions, ?pos:haxe.PosInfos):Void {\n\t\t#if js\n            var console:js.html.Console = js.Browser.console;\n\t\t\tswitch(func) {\n\t\t\t\tcase Fatal: {\n\t\t\t\t\tconsole.error(pos.fileName + ':' + pos.lineNumber, v);\n\t\t\t\t\tthrow new String('FATAL EXCEPTION: ' + pos.fileName + ':' + pos.lineNumber + ': ' + v.toString());\n\t\t\t\t}\n\t\t\t\tcase Error: console.error(pos.fileName + ':' + pos.lineNumber, v);\n\t\t\t\tcase Warn: console.warn(pos.fileName + ':' + pos.lineNumber, v);\n\t\t\t\tcase Info: console.info(pos.fileName + ':' + pos.lineNumber, v);\n\t\t\t\tcase Debug: console.debug(pos.fileName + ':' + pos.lineNumber, v);\n\t\t\t\tdefault: console.log(pos.fileName + ':' + pos.lineNumber, v);\n\t\t\t}\n\t\t#else\n\t\t\ttrace(v, pos);\n\t\t#end\n\t}\n\n\t/**\n\t * Use for show-stopping errors\n\t * @param value the message / object to log\n\t */\n\tmacro public static function fatal(value:Dynamic):Expr {\n\t\t#if log_fatal\n\t\t\treturn macro @:pos(Context.currentPos()) mammoth.Log.log($value, mammoth.Log.LogFunctions.Fatal);\n\t\t#else\n\t\t\treturn macro null;\n\t\t#end\n\t}\n\n\n\t/**\n\t * Use for crashes and exceptions, and any other errors that aren't\n\t * necessarily show-stopping but require intervention.\n\t * @param value the message / object to log\n\t */\n\tmacro public static function error(value:Dynamic):Expr {\n\t\t#if log_error\n\t\t\treturn macro @:pos(Context.currentPos()) mammoth.Log.log($value, mammoth.Log.LogFunctions.Error);\n\t\t#else\n\t\t\treturn macro null;\n\t\t#end\n\t}\n\n\t/**\n\t * Use for indicating incorrect behaviour (but execution can be continued).\n\t * @param value the message / object to log\n\t */\n\tmacro public static function warning(value:Dynamic):Expr {\n\t\t#if log_warning\n\t\t\treturn macro @:pos(Context.currentPos()) mammoth.Log.log($value, mammoth.Log.LogFunctions.Warn);\n\t\t#else\n\t\t\treturn macro null;\n\t\t#end\n\t}\n\n\t/**\n\t * Use to indicate normal behaviour\n\t * @param value the message / object to log\n\t */\n\tmacro public static function info(value:Dynamic):Expr {\n\t\t#if log_info\n\t\t\treturn macro @:pos(Context.currentPos()) mammoth.Log.log($value, mammoth.Log.LogFunctions.Info);\n\t\t#else\n\t\t\treturn macro null;\n\t\t#end\n\t}\n\n\t/**\n\t * Use for logging behind-the-scenes information.\n\t * @param value the message / object to log\n\t */\n\tmacro public static function debug(value:Dynamic):Expr {\n\t\t#if debug\n\t\t\treturn macro @:pos(Context.currentPos()) mammoth.Log.log($value, mammoth.Log.LogFunctions.Debug);\n\t\t#else\n\t\t\treturn macro null;\n\t\t#end\n\t}\n}","package mammoth.platform.js;\n\nimport js.html.ArrayBuffer;\nimport js.html.DataView;\nimport js.html.XMLHttpRequest;\nimport js.html.XMLHttpRequestResponseType;\nimport haxe.io.Bytes;\nimport haxe.Json;\nimport mammoth.debug.Exception;\nimport promhx.Deferred;\nimport promhx.Promise;\n\nclass Assets {\n\tpublic function new() {}\n\n\tpublic function load(path:String):Promise<Bytes> {\n\t\tvar d:Deferred<Bytes> = new Deferred<Bytes>();\n\t\tvar p:Promise<Bytes> = d.promise();\n\n\t\tvar xhr:XMLHttpRequest = new XMLHttpRequest();\n\t\txhr.open(\"GET\", path, true);\n\t\txhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n\t\txhr.responseType = XMLHttpRequestResponseType.ARRAYBUFFER;\n\t\txhr.onload = function() {\n\t\t\tif(xhr.status >= 200 && xhr.status < 300) {\n\t\t\t\tvar buffer:ArrayBuffer = cast xhr.response;\n\t\t\t\tvar view:DataView = new DataView(buffer);\n\t\t\t\tvar bytes:Bytes = Bytes.alloc(view.byteLength);\n\t\t\t\tfor(i in 0...view.byteLength) bytes.set(i, view.getUint8(i));\n\t\t\t\td.resolve(bytes);\n\t\t\t}\n\t\t\telse {\n\t\t\t\td.throwError(new Exception('error ${xhr.status}: ${xhr.statusText}', false, 'HTTPResponse'));\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() d.throwError(new Exception('unknown error', false, 'HTTPRequest'));\n\t\txhr.onabort = function() d.throwError(new Exception('aborted', false, 'HTTPRequest'));\n\t\txhr.ontimeout = function() d.throwError(new Exception('timed out', false, 'HTTPRequest'));\n\t\txhr.send();\n\n\t\treturn p;\n\t}\n\n\tpublic function loadJSON(path:String):Promise<Dynamic> {\n\t\tvar d:Deferred<Dynamic> = new Deferred<Dynamic>();\n\t\tvar p:Promise<Dynamic> = d.promise();\n\n\t\tload(path)\n\t\t\t.then(function(b:Bytes) { d.resolve(Json.parse(b.toString())); })\n\t\t\t.catchError(function(e:Dynamic) { d.throwError(e); });\n\n\t\treturn p;\n\t}\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.gl.js;\n\nimport haxe.ds.StringMap;\n\nimport js.Browser;\nimport js.html.CanvasElement;\nimport js.html.webgl.RenderingContext;\n\nimport mammoth.platform.ArrayBufferView;\nimport mammoth.platform.Float32Array;\nimport mammoth.platform.Int32Array;\nimport mammoth.types.Colour;\n\n@:allow(mammoth.Mammoth)\nclass Graphics {\n    public var context:RenderingContext;\n\n    private var width(get, never):Float;\n    private inline function get_width():Float return context.drawingBufferWidth;\n\n    private var height(get, never):Float;\n    private inline function get_height():Float return context.drawingBufferHeight;\n\n    private var aspectRatio(get, never):Float;\n    private inline function get_aspectRatio():Float\n        return (context.canvas.clientWidth / context.canvas.clientHeight);\n\n\tprivate var extensions:StringMap<Dynamic> = new StringMap<Dynamic>();\n\n    private function new() {}\n\n    private function init() {\n        // create our canvas\n        var canvas:CanvasElement = Browser.document.createCanvasElement();\n        context = canvas.getContextWebGL({\n            alpha: false,\n            antialias: false,\n            depth: true,\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: true,\n            stencil: true,\n        });\n\n        // add the GL extensions\n        if(context != null) {\n            //context.pixelStorei(GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\n            extensions.set('texture_float', context.getExtension(\"OES_texture_float\"));\n            extensions.set('texture_float_linear', context.getExtension(\"OES_texture_float_linear\"));\n            extensions.set('texture_half_float', context.getExtension(\"OES_texture_half_float\"));\n            extensions.set('texture_half_float_linear', context.getExtension(\"OES_texture_half_float_linear\"));\n\t\t\textensions.set('frag_depth', context.getExtension(\"EXT_frag_depth\"));\n            extensions.set('depth_texture', context.getExtension(\"WEBGL_depth_texture\"));\n            extensions.set('shader_texture_lod', context.getExtension(\"EXT_shader_texture_lod\"));\n            extensions.set('standard_derivatives', context.getExtension(\"OES_standard_derivatives\"));\n            extensions.set('texture_filter_anisotropic', context.getExtension(\"EXT_texture_filter_anisotropic\"));\n            if(extensions.get('texture_filter_anisotropic') == null)\n                extensions.set('texture_filter_anisotropic', context.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\"));\n            extensions.set('draw_buffers', context.getExtension(\"WEBGL_draw_buffers\"));\n        }\n\n        // add the canvas to the body\n        Browser.document.body.appendChild(canvas);\n    }\n\n    public function checkWindowSize() {\n        var displayWidth:Int  = Math.floor(context.canvas.clientWidth  * Browser.window.devicePixelRatio);\n        var displayHeight:Int = Math.floor(context.canvas.clientHeight * Browser.window.devicePixelRatio);\n\n        if(context.canvas.width != displayWidth || context.canvas.height != displayHeight) {\n            context.canvas.width = displayWidth;\n            context.canvas.height = displayHeight;\n        }\n    }\n\n\tpublic inline function getExtension(name:String):Dynamic return context.getExtension(name);\n\tpublic inline function activeTexture(texture:Int):Void context.activeTexture(texture);\n\tpublic inline function attachShader(program:Program, shader:Shader):Void context.attachShader(program, shader);\n\tpublic inline function bindAttribLocation(program:Program, index:Int, name:String):Void context.bindAttribLocation(program, index, name);\n\tpublic inline function bindBuffer(target:Int, buffer:Buffer):Void context.bindBuffer(target, buffer);\n\tpublic inline function bindFramebuffer(target:Int, framebuffer:Framebuffer):Void context.bindFramebuffer(target, framebuffer);\n\tpublic inline function bindRenderbuffer(target:Int, renderbuffer:Renderbuffer):Void context.bindRenderbuffer(target, renderbuffer);\n\tpublic inline function bindTexture(target:Int, texture:Texture):Void context.bindTexture(target, texture);\n\tpublic inline function blendColor(colour:Colour):Void context.blendColor(colour.r, colour.g, colour.b, colour.a);\n\tpublic inline function blendEquation(mode:Int):Void context.blendEquation(mode);\n\tpublic inline function blendEquationSeparate(modeRGB:Int, modeAlpha:Int):Void context.blendEquationSeparate(modeRGB, modeAlpha);\n\tpublic inline function blendFunc(sfactor:Int, dfactor:Int):Void context.blendFunc(sfactor, dfactor);\n\tpublic inline function blendFuncSeparate(srcRGB:Int, dstRGB:Int, srcAlpha:Int, dstAlpha:Int):Void context.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);\n\t/*@:overload(function(target:Int, size:Int, usage:Int):Void {})\n\t// @:overload(function(target:Int, data:js.html.ArrayBufferView, usage:Int):Void {})\n\t// @:overload(function(target:Int, data:js.html.ArrayBuffer, usage:Int):Void {})*/\n\tpublic inline function bufferData(target:Int, data:Dynamic, usage:Int):Void context.bufferData(target, data, usage);\n\t/*@:overload(function(target:Int, offset:Int, data:js.html.ArrayBufferView):Void {})\n\t// @:overload(function(target:Int, offset:Int, data:js.html.ArrayBuffer):Void {})*/\n\t// public inline function bufferSubData(target:Int, offset:Int, data:Dynamic):Void context.bufferSubData(target, offset, data);\n\tpublic inline function checkFramebufferStatus(target:Int):Int return context.checkFramebufferStatus(target);\n\tpublic inline function clear(mask:Int):Void context.clear(mask);\n\tpublic inline function clearColor(colour:Colour):Void context.clearColor(colour.r, colour.g, colour.b, colour.a);\n\t// public inline function clearDepth(depth:Float):Void;\n\t// public inline function clearStencil(s:Int):Void;\n\t// public inline function colorMask(red:Bool, green:Bool, blue:Bool, alpha:Bool):Void;\n\tpublic inline function compileShader(shader:Shader):Void context.compileShader(shader);\n\t// public inline function compressedTexImage2D(target:Int, level:Int, internalformat:Int, width:Int, height:Int, border:Int, data:js.html.ArrayBufferView):Void;\n\t// public inline function compressedTexSubImage2D(target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, data:js.html.ArrayBufferView):Void;\n\t// public inline function copyTexImage2D(target:Int, level:Int, internalformat:Int, x:Int, y:Int, width:Int, height:Int, border:Int):Void;\n\t// public inline function copyTexSubImage2D(target:Int, level:Int, xoffset:Int, yoffset:Int, x:Int, y:Int, width:Int, height:Int):Void;\n\tpublic inline function createBuffer():Buffer return context.createBuffer();\n\tpublic inline function createFramebuffer():Framebuffer return context.createFramebuffer();\n\tpublic inline function createProgram():Program return context.createProgram();\n\tpublic inline function createRenderbuffer():Renderbuffer return context.createRenderbuffer();\n\tpublic inline function createShader(type:Int):Shader return context.createShader(type);\n\tpublic inline function createTexture():Texture return context.createTexture();\n\tpublic inline function cullFace(mode:Int):Void context.cullFace(mode);\n\tpublic inline function deleteBuffer(buffer:Buffer):Void context.deleteBuffer(buffer);\n\tpublic inline function deleteFramebuffer(framebuffer:Framebuffer):Void context.deleteFramebuffer(framebuffer);\n\tpublic inline function deleteProgram(program:Program):Void context.deleteProgram(program);\n\tpublic inline function deleteRenderbuffer(renderbuffer:Renderbuffer):Void context.deleteRenderbuffer(renderbuffer);\n\tpublic inline function deleteShader(shader:Shader):Void context.deleteShader(shader);\n\tpublic inline function deleteTexture(texture:Texture):Void context.deleteTexture(texture);\n\tpublic inline function depthFunc(func:Int):Void context.depthFunc(func);\n\tpublic inline function depthMask(flag:Bool):Void return context.depthMask(flag);\n\t// public inline function depthRange(zNear:Float, zFar:Float):Void;\n\t// public inline function detachShader(program:Program, shader:Shader):Void;\n\tpublic inline function disable(cap:Int):Void context.disable(cap);\n\tpublic inline function disableVertexAttribArray(index:Int):Void context.disableVertexAttribArray(index);\n\tpublic inline function drawArrays(mode:Int, first:Int, count:Int):Void context.drawArrays(mode, first, count);\n\tpublic inline function drawElements(mode:Int, count:Int, type:Int, offset:Int):Void context.drawElements(mode, count, type, offset);\n\tpublic inline function enable(cap:Int):Void context.enable(cap);\n\tpublic inline function enableVertexAttribArray(index:Int):Void context.enableVertexAttribArray(index);\n\tpublic inline function finish():Void context.finish();\n\tpublic inline function flush():Void context.flush();\n\tpublic inline function framebufferRenderbuffer(target:Int, attachment:Int, renderbuffertarget:Int, renderbuffer:Renderbuffer):Void\n\t\tcontext.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);\n\tpublic inline function framebufferTexture2D(target:Int, attachment:Int, textarget:Int, texture:Texture, level:Int):Void\n\t\tcontext.framebufferTexture2D(target, attachment, textarget, texture, level);\n\tpublic inline function frontFace(mode:Int):Void context.frontFace(mode);\n\tpublic inline function generateMipmap(target:Int):Void context.generateMipmap(target);\n\t// public inline function getActiveAttrib(program:Program, index:Int):ActiveInfo;\n\t// public inline function getActiveUniform(program:Program, index:Int):ActiveInfo;\n\t// public inline function getAttachedShaders(program:Program):Array<Shader>;\n\tpublic inline function getAttribLocation(program:Program, name:String):Int return context.getAttribLocation(program, name);\n\t// public inline function getBufferParameter(target:Int, pname:Int):Dynamic;\n\t// public inline function getParameter(pname:Int):Dynamic;\n\t// public inline function getError():Int;\n\t// public inline function getFramebufferAttachmentParameter(target:Int, attachment:Int, pname:Int):Dynamic;\n\tpublic inline function getProgramParameter(program:Program, pname:Int):Dynamic return context.getProgramParameter(program, pname);\n\tpublic inline function getProgramInfoLog(program:Program):String return context.getProgramInfoLog(program);\n\t// public inline function getRenderbufferParameter(target:Int, pname:Int):Dynamic;\n\tpublic inline function getShaderParameter(shader:Shader, pname:Int):Dynamic return context.getShaderParameter(shader, pname);\n\t// public inline function getShaderPrecisionFormat(shadertype:Int, precisiontype:Int):ShaderPrecisionFormat;\n\tpublic inline function getShaderInfoLog(shader:Shader):String return context.getShaderInfoLog(shader);\n\t// public inline function getShaderSource(shader:Shader):String;\n\t// public inline function getTexParameter(target:Int, pname:Int):Dynamic;\n\tpublic inline function getUniform(program:Program, location:UniformLocation):Dynamic return context.getUniform(program, location);\n\tpublic inline function getUniformLocation(program:Program, name:String):UniformLocation return context.getUniformLocation(program, name);\n\tpublic inline function getVertexAttrib(index:Int, pname:Int):Dynamic return context.getVertexAttrib(index, pname);\n\t// public inline function getVertexAttribOffset(index:Int, pname:Int):Int;\n\t// public inline function hint(target:Int, mode:Int):Void;\n\t// public inline function isBuffer(buffer:Buffer):Bool;\n\t// public inline function isEnabled(cap:Int):Bool;\n\t// public inline function isFramebuffer(framebuffer:Framebuffer):Bool;\n\t// public inline function isProgram(program:Program):Bool;\n\t// public inline function isRenderbuffer(renderbuffer:Renderbuffer):Bool;\n\t// public inline function isShader(shader:Shader):Bool;\n\t// public inline function isTexture(texture:Texture):Bool;\n\t// public inline function lineWidth(width:Float):Void;\n\tpublic inline function linkProgram(program:Program):Void return context.linkProgram(program);\n\tpublic inline function pixelStorei(pname:Int, param:Int):Void context.pixelStorei(pname, param);\n\t// public inline function polygonOffset(factor:Float, units:Float):Void;\n\t// public inline function readPixels(x:Int, y:Int, width:Int, height:Int, format:Int, type:Int, pixels:js.html.ArrayBufferView):Void;\n\t// public inline function renderbufferStorage(target:Int, internalformat:Int, width:Int, height:Int):Void;\n\t// public inline function sampleCoverage(value:Float, invert:Bool):Void;\n\tpublic inline function scissor(x:Int, y:Int, width:Int, height:Int):Void context.scissor(x, y, width, height);\n\tpublic inline function shaderSource(shader:Shader, source:String):Void context.shaderSource(shader, source);\n\t// public inline function stencilFunc(func:Int, ref:Int, mask:Int):Void;\n\t// public inline function stencilFuncSeparate(face:Int, func:Int, ref:Int, mask:Int):Void;\n\t// public inline function stencilMask(mask:Int):Void;\n\t// public inline function stencilMaskSeparate(face:Int, mask:Int):Void;\n\t// public inline function stencilOp(fail:Int, zfail:Int, zpass:Int):Void;\n\t// public inline function stencilOpSeparate(face:Int, fail:Int, zfail:Int, zpass:Int):Void;\n\t// @:overload(function(target:Int, level:Int, internalformat:Int, width:Int, height:Int, border:Int, format:Int, type:Int, pixels:js.html.ArrayBufferView):Void {})\n\t// @:overload(function(target:Int, level:Int, internalformat:Int, format:Int, type:Int, pixels:js.html.ImageData):Void {})\n\t// @:overload(function(target:Int, level:Int, internalformat:Int, format:Int, type:Int, image:js.html.ImageElement):Void {})\n\t// @:overload(function(target:Int, level:Int, internalformat:Int, format:Int, type:Int, canvas:js.html.CanvasElement):Void {})\n\t// public inline function texImage2D(target:Int, level:Int, internalformat:Int, format:Int, type:Int, video:js.html.VideoElement):Void;\n\tpublic inline function texImage2D(target:Int, level:Int, internalformat:Int, width:Int, height:Int, border:Int, format:Int, type:Int, pixels:ArrayBufferView):Void\n\t\tcontext.texImage2D(target, level, internalformat, width, height, border, format, type, pixels);\n\t// public inline function texParameterf(target:Int, pname:Int, param:Float):Void;\n\tpublic inline function texParameteri(target:Int, pname:Int, param:Int):Void context.texParameteri(target, pname, param);\n\t// @:overload(function(target:Int, level:Int, xoffset:Int, yoffset:Int, width:Int, height:Int, format:Int, type:Int, pixels:js.html.ArrayBufferView):Void {})\n\t// @:overload(function(target:Int, level:Int, xoffset:Int, yoffset:Int, format:Int, type:Int, pixels:js.html.ImageData):Void {})\n\t// @:overload(function(target:Int, level:Int, xoffset:Int, yoffset:Int, format:Int, type:Int, image:js.html.ImageElement):Void {})\n\t// @:overload(function(target:Int, level:Int, xoffset:Int, yoffset:Int, format:Int, type:Int, canvas:js.html.CanvasElement):Void {})\n\t// public inline function texSubImage2D(target:Int, level:Int, xoffset:Int, yoffset:Int, format:Int, type:Int, video:js.html.VideoElement):Void;\n\tpublic inline function uniform1f(location:UniformLocation, x:Float):Void context.uniform1f(location, x);\n    public inline function uniform1fv(location:UniformLocation, v:Float32Array) context.uniform1fv(location, v);\n\tpublic inline function uniform1i(location:UniformLocation, x:Int):Void context.uniform1i(location, x);\n    public inline function uniform1iv(location:UniformLocation, v:Int32Array) context.uniform1iv(location, v);\n\tpublic inline function uniform2f(location:UniformLocation, x:Float, y:Float):Void context.uniform2f(location, x, y);\n\tpublic inline function uniform2fv(location:UniformLocation, v:Float32Array):Void context.uniform2fv(location, v);\n    public inline function uniform2i(location:UniformLocation, x:Int, y:Int):Void context.uniform2i(location, x, y);\n    public inline function uniform2iv(location:UniformLocation, v:Int32Array):Void context.uniform2iv(location, v);\n    public inline function uniform3f(location:UniformLocation, x:Float, y:Float, z:Float):Void context.uniform3f(location, x, y, z);\n    public inline function uniform3fv(location:UniformLocation, v:Float32Array):Void context.uniform3fv(location, v);\n    public inline function uniform3i(location:UniformLocation, x:Int, y:Int, z:Int):Void context.uniform3i(location, x, y, z);\n    public inline function uniform3iv(location:UniformLocation, v:Int32Array):Void context.uniform3iv(location, v);\n    public inline function uniform4f(location:UniformLocation, x:Float, y:Float, z:Float, w:Float):Void context.uniform4f(location, x, y, z, w);\n    public inline function uniform4fv(location:UniformLocation, v:Float32Array):Void context.uniform4fv(location, v);\n    public inline function uniform4i(location:UniformLocation, x:Int, y:Int, z:Int, w:Int):Void context.uniform4i(location, x, y, z, w);\n    public inline function uniform4iv(location:UniformLocation, v:Int32Array):Void context.uniform4iv(location, v);\n    public inline function uniformMatrix2fv(location:UniformLocation, v:Float32Array):Void context.uniformMatrix2fv(location, false, v);\n    public inline function uniformMatrix3fv(location:UniformLocation, v:Float32Array):Void context.uniformMatrix3fv(location, false, v);\n    public inline function uniformMatrix4fv(location:UniformLocation, v:Float32Array):Void context.uniformMatrix4fv(location, false, v);\n\tpublic inline function useProgram(program:Program):Void return context.useProgram(program);\n\t// public inline function validateProgram(program:Program):Void;\n\t// public inline function vertexAttrib1f(indx:Int, x:Float):Void;\n\t// @:overload(function(indx:Int, values:js.html.Float32Array):Void {})\n\t// public inline function vertexAttrib1fv(indx:Int, values:Array<Float>):Void;\n\t// public inline function vertexAttrib2f(indx:Int, x:Float, y:Float):Void;\n\t// @:overload(function(indx:Int, values:js.html.Float32Array):Void {})\n\t// public inline function vertexAttrib2fv(indx:Int, values:Array<Float>):Void;\n\t// public inline function vertexAttrib3f(indx:Int, x:Float, y:Float, z:Float):Void;\n\t// @:overload(function(indx:Int, values:js.html.Float32Array):Void {})\n\t// public inline function vertexAttrib3fv(indx:Int, values:Array<Float>):Void;\n\t// public inline function vertexAttrib4f(indx:Int, x:Float, y:Float, z:Float, w:Float):Void;\n\t// @:overload(function(indx:Int, values:js.html.Float32Array):Void {})\n\t// public inline function vertexAttrib4fv(indx:Int, values:Array<Float>):Void;\n\tpublic inline function vertexAttribPointer(indx:Int, size:Int, type:Int, normalized:Bool, stride:Int, offset:Int):Void context.vertexAttribPointer(indx, size, type, normalized, stride, offset);\n\tpublic inline function viewport(x:Int, y:Int, width:Int, height:Int):Void context.viewport(x, y, width, height);\n}","package mammoth.platform.js;\n\nimport mammoth.Mammoth;\nimport js.html.MouseEvent;\nimport js.html.DOMRect;\n\nclass Input {\n    public var mouseX(default, null):Float = 0;\n    public var mouseY(default, null):Float = 0;\n    public var mouseDown(default, null):Bool = false;\n\n    public function new() {}\n\n    public function init():Void {\n        Mammoth.gl.context.canvas.addEventListener('mousemove', updateMousePosition);\n        Mammoth.gl.context.canvas.addEventListener('mousedown', updateMouseDown);\n        Mammoth.gl.context.canvas.addEventListener('mouseup', updateMouseUp);\n    }\n\n    private function updateMousePosition(evt:MouseEvent):Void {\n        var rect:DOMRect = Mammoth.gl.context.canvas.getBoundingClientRect();\n        mouseX = Math.ffloor((evt.clientX - rect.left) / (rect.right - rect.left) * Mammoth.gl.context.canvas.width);\n        mouseY = Math.ffloor((evt.clientY - rect.top) / (rect.bottom - rect.top) * Mammoth.gl.context.canvas.height);\n    }\n\n    private function updateMouseDown(evt:MouseEvent):Void {\n        if(evt.button == 0) mouseDown = true;\n    }\n\n    private function updateMouseUp(evt:MouseEvent):Void {\n        if(evt.button == 0) mouseDown = false;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth;\n\nimport haxe.ds.StringMap;\nimport mammoth.types.Mesh;\nimport mammoth.types.Material;\n\nclass Resources {\n    public var meshes:StringMap<Mesh> = new StringMap<Mesh>();\n    public var materials:StringMap<Material> = new StringMap<Material>();\n\n    public function new(){}\n}","package mammoth;\n\nimport haxe.Timer;\n\nclass Stats {\n    public var drawCalls:Int = 0;\n    public var triangles:Int = 0;\n\n    public var renderTime:Float = 0;\n    public var fps(get, never):Float;\n    private function get_fps():Float {\n        if(Math.abs(renderTime) <= 0.00000001) return -1;\n        return 1 / renderTime;\n    }\n\n    private var renderFrameCount:Int = 0;\n    private var renderStart:Float = 0;\n    private var renderEnd:Float = 0;\n\n    public function new() {}\n\n    public function startRenderTimer():Void {\n        if(renderFrameCount == 0) {\n            renderStart = Timer.stamp();\n        }\n    }\n\n    public function endRenderTimer():Void {\n        renderFrameCount++;\n        if(renderFrameCount == 120) {\n            renderEnd = Timer.stamp();\n            renderTime = (renderEnd - renderStart) / 120;\n            renderFrameCount = 0;\n        }\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.platform.js;\n\nimport js.Browser;\n\n@:allow(mammoth.Mammoth)\nclass Timing {\n    public function new() {}\n\n    private var animationFrameID:Int = 0;\n    private var time:Float = 0;\n    private var lastTime:Float = 0;\n    private var accumulator:Float = 0;\n\n    public var timescale:Float = 1.0;\n    public var dt(default, null):Float = 1 / 30;\n    public var alpha(default, null):Float = 0;\n\n    private var onUpdate:Float->Void;\n    private var onRender:Float->Float->Void;\n\n    private function onRenderFrame(ts:Float):Void {\n        time = ts / 1000;\n\n        // figure out how long since we last ran\n        var delta:Float = (time - lastTime) * timescale;\n        lastTime = time;\n\n        // updates\n        accumulator += delta;\n        while(accumulator >= dt) {\n            onUpdate(dt);\n            accumulator -= dt;\n        }\n\n        // renders\n        alpha = accumulator / dt;\n        onRender(delta, alpha);\n\n        // go on to the next frame\n        requestFrame();\n    }\n\n    private inline function requestFrame() {\n        animationFrameID = Browser.window.requestAnimationFrame(onRenderFrame);\n    }\n\n    private function start() {\n        requestFrame();\n    }\n\n    private function stop() {\n        Browser.window.cancelAnimationFrame(animationFrameID);\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth;\n\nimport edge.Engine;\nimport edge.Phase;\nimport mammoth.gl.Graphics;\nimport mammoth.platform.Assets;\nimport mammoth.Resources;\nimport mammoth.platform.Input;\nimport mammoth.platform.Timing;\nimport mammoth.debug.DebugView;\nimport tusk.Tusk;\n\n@:expose\nclass Mammoth {\n\t// parts of our system\n    public static var engine:Engine;\n    public static var preUpdatePhase:Phase;\n    public static var updatePhase:Phase;\n    public static var postUpdatePhase:Phase;\n    public static var renderPhase:Phase;\n\n    public static var timing:Timing = new Timing();\n    public static var gl:Graphics = new Graphics();\n    public static var assets:Assets = new Assets();\n    public static var resources:Resources = new Resources();\n    public static var input:Input = new Input();\n    public static var stats:Stats = new Stats();\n    private static var debugView:DebugView;\n\n    // public timing variables\n    public static var time(get, never):Float;\n    private inline static function get_time():Float return timing.time;\n    public static var alpha(get, never):Float;\n    private inline static function get_alpha():Float return timing.alpha;\n\n    // public size variables\n    public static var width(get, never):Float;\n    private inline static function get_width():Float return gl.width;\n    public static var height(get, never):Float;\n    private inline static function get_height():Float return gl.height;\n    public static var aspectRatio(get, never):Float;\n    private inline static function get_aspectRatio():Float return gl.aspectRatio;\n\n    static macro function getDefine(key:String):Expr return macro $v{Context.definedValue(key)};\n    static macro function isDefined(key:String):Expr return macro $v{Context.defined(key)};\n    \n    public static function init(?onReady:Void->Void, updateRate:Float=60):Void {\n        // initialize our subsystems\n        gl.init();\n        input.init();\n        debugView = new DebugView();\n\n        // calculate the clock period\n        timing.dt = 1 / updateRate;\n\n        // initialize the ECS\n        engine = new Engine();\n        preUpdatePhase = engine.createPhase();\n        updatePhase = engine.createPhase();\n        postUpdatePhase = engine.createPhase();\n        renderPhase = engine.createPhase();\n\n        // initialize our pre- and post- systems\n        preUpdatePhase.add(new mammoth.systems.PreTransformSystem());\n\n        // initialize our rendering\n        renderPhase.add(new mammoth.systems.ModelMatrixSystem());\n        renderPhase.add(new mammoth.systems.CameraSystem());\n        renderPhase.add(new mammoth.systems.DirectionalLightSystem());\n        renderPhase.add(new mammoth.systems.DirectionalShadowSystem());\n        renderPhase.add(new mammoth.systems.RenderSystem());\n\n        if(onReady != null)\n            onReady();\n    }\n\n    public static function begin() {\n        timing.onUpdate = onUpdate;\n        timing.onRender = onRender;\n        timing.start();\n    }\n\n    public static function end() {\n        timing.stop();\n    }\n\n    private static function onUpdate(dt:Float):Void {\n        Tusk.draw.newFrame();\n        Tusk.updateInput(input.mouseX, input.mouseY, input.mouseDown);\n\n        preUpdatePhase.update(dt);\n        updatePhase.update(dt);\n        postUpdatePhase.update(dt);\n\n        Tusk.window(tusk.Control.uuid(), Mammoth.width - 160, 10, 150, 75, 'Stats');\n        Tusk.label('Render t: ' + Math.fround(stats.renderTime * 1000 * 10) / 10 + 'ms');\n        Tusk.label('FPS: ' + Math.fround(stats.fps * 10) / 10);\n        Tusk.label('Draw calls: ' + stats.drawCalls);\n        Tusk.label('Triangles: ' + stats.triangles);\n    }\n\n    private static function onRender(dt:Float, alpha:Float):Void {\n        stats.drawCalls = 0;\n        stats.triangles = 0;\n\n        stats.startRenderTimer();\n        gl.checkWindowSize();\n        renderPhase.update(dt);\n        stats.endRenderTimer();\n\n        debugView.draw();\n    }\n}\n","package tusk;\n\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\n\nclass Control {\n    private static var i:Int = 0;\n    macro public static function uuid():ExprOf<Int> {\n        return macro $v{i++};\n    }\n\n    public var clicked:Bool = false;\n    public var state:InputState = InputState.Normal;\n\n    public function new() {}\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.components;\n\nimport edge.IComponent;\nimport glm.Mat4;\nimport glm.Vec2;\nimport mammoth.types.Colour;\nimport mammoth.defaults.Colours;\n\nenum ProjectionMode {\n    Orthographic(size:Float);\n    Perspective(fieldOfView:Float);\n}\n\nclass Camera implements IComponent {\n    public var pDirty:Bool = true;\n\n    public var near:Float = 0.1;\n    public var far:Float = 100;\n    public var aspect:Float = 16/9;\n    public var projection:ProjectionMode = ProjectionMode.Perspective(60);\n    public var viewportMin:Vec2 = new Vec2(0, 0);\n    public var viewportMax:Vec2 = new Vec2(1, 1);\n    public var clearColour:Colour = Colours.Black;\n\n    public var v:Mat4 = new Mat4(1.0);\n    public var p:Mat4 = new Mat4(1.0);\n    public var vp:Mat4 = new Mat4(1.0);\n\n    public function new() {}\n\n    public function setNearFar(near:Float, far:Float):Camera {\n        this.near = near;\n        this.far = far;\n        pDirty = true;\n        return this;\n    }\n\n    public function setProjection(projection:ProjectionMode):Camera {\n        this.projection = projection;\n        pDirty = true;\n        return this;\n    }\n\n    public function setViewport(min:Vec2, max:Vec2):Camera {\n        this.viewportMin = min;\n        this.viewportMax = max;\n        return this;\n    }\n\n    public function setClearColour(colour:Colour):Camera {\n        this.clearColour = colour;\n        return this;\n    }\n}\n","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.components;\n\nimport edge.IComponent;\nimport mammoth.types.Colour;\nimport mammoth.defaults.Colours;\nimport mammoth.gl.Framebuffer;\nimport mammoth.gl.Texture;\n\nclass DirectionalLight implements IComponent {\n\tpublic var colour:Colour = Colours.White;\n\tpublic var direction:Vec4 = new Vec4();\n\n\tpublic var shadowFramebuffer:Framebuffer = null;\n\tpublic var colourmap:Texture = null;\n\tpublic var shadowmap:Texture = null;\n\n\tpublic function new() {}\n\n\tpublic function setColour(colour:Colour):DirectionalLight {\n\t\tthis.colour = colour;\n\t\treturn this;\n\t}\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.components;\n\nimport edge.IComponent;\nimport mammoth.types.Material;\nimport mammoth.types.Mesh;\nimport mammoth.types.MaterialData;\n\nclass MeshRenderer implements IComponent {\n\tpublic var mesh:Mesh;\n\tpublic var material:Material;\n\tpublic var materialData:MaterialData = new MaterialData();\n\n\tpublic function new() {}\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.components;\n\nimport edge.IComponent;\nimport mammoth.types.Colour;\nimport mammoth.defaults.Colours;\n\nclass PointLight implements IComponent {\n    public var colour:Colour = Colours.White;\n    public var distance:Float = 25;\n\n    public function new() {}\n\n    public function setColour(colour:Colour):PointLight {\n        this.colour = colour;\n        return this;\n    }\n\n    public function setDistance(distance:Float):PointLight {\n        this.distance = distance;\n        return this;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.components;\n\nimport edge.IComponent;\nimport glm.Mat4;\nimport glm.Vec3;\nimport glm.Quat;\n\n@:allow(mammoth.systems.ModelMatrixSystem)\n@:allow(mammoth.systems.PreTransformSystem)\n@:allow(mammoth.systems.PostTransformSystem)\nclass Transform implements IComponent {\n    public var name:String = '';\n\tpublic var parent(default, set):Transform = null;\n\n\tpublic var position(default, set):Vec3 = new Vec3();\n\tpublic var rotation(default, set):Quat = Quat.identity(new Quat());\n\tpublic var scale(default, set):Vec3 = new Vec3(1, 1, 1);\n\n    private var lastPosition:Vec3 = new Vec3();\n    private var lastRotation:Quat = new Quat();\n    private var lastScale:Vec3 = new Vec3();\n    \n    public var m:Mat4 = Mat4.identity(new Mat4());\n\n    public function new() {}\n\n    private inline function set_parent(newParent:Transform):Transform {\n        // don't let us parent ourselves!\n        if(newParent == this) return parent;\n\n        parent = newParent;\n        return parent;\n    }\n\n    private inline function set_position(newPosition:Vec3):Vec3 {\n        position.x = newPosition.x;\n        position.y = newPosition.y;\n        position.z = newPosition.z;\n        return position;\n    }\n\n    private inline function set_rotation(rot:Quat):Quat {\n        rotation.x = rot.x;\n        rotation.y = rot.y;\n        rotation.z = rot.z;\n        rotation.w = rot.w;\n        return rotation;\n    }\n\n    private inline function set_scale(newScale:Vec3):Vec3 {\n        scale.x = newScale.x;\n        scale.y = newScale.y;\n        scale.z = newScale.z;\n        return scale;\n    }\n}\n","package mammoth.debug;\n\nimport js.html.ImageElement;\nimport mammoth.gl.Shader;\nimport mammoth.gl.Program;\nimport mammoth.gl.UniformLocation;\nimport mammoth.gl.Buffer;\nimport mammoth.gl.Texture;\nimport tusk.Tusk;\nimport mammoth.gl.GL;\n\nclass DebugView {\n    private var program:Program;\n    private var buffer:Buffer;\n    private var fontImage:ImageElement;\n    private var fontTexture:Texture;\n\n    private var positionLoc:Int = 0;\n    private var uvLoc:Int = 0;\n    private var colourLoc:Int = 0;\n\n    private var vpLoc:UniformLocation;\n    private var textureLoc:UniformLocation;\n\n    public function new() {\n        // compile the vertex shader\n        var vert:Shader = Mammoth.gl.createShader(GL.VERTEX_SHADER);\n        Mammoth.gl.shaderSource(vert, Tusk.vertexShaderSrc);\n        Mammoth.gl.compileShader(vert);\n\t\tif(!Mammoth.gl.getShaderParameter(vert, GL.COMPILE_STATUS)) {\n\t\t\tvar info:String = Mammoth.gl.getShaderInfoLog(vert);\n\t\t\tthrow new Exception(info, true, 'CompileVertShader');\n\t\t}\n\n        // compile the fragment shader\n        var frag:Shader = Mammoth.gl.createShader(GL.FRAGMENT_SHADER);\n        Mammoth.gl.shaderSource(frag, Tusk.fragmentShaderSrc);\n        Mammoth.gl.compileShader(frag);\n\t\tif(!Mammoth.gl.getShaderParameter(frag, GL.COMPILE_STATUS)) {\n\t\t\tvar info:String = Mammoth.gl.getShaderInfoLog(frag);\n\t\t\tthrow new Exception(info, true, 'CompileFragShader');\n\t\t}\n\n        // compile the program\n        program = Mammoth.gl.createProgram();\n        Mammoth.gl.attachShader(program, vert);\n        Mammoth.gl.attachShader(program, frag);\n        Mammoth.gl.linkProgram(program);\n\t\tif(!Mammoth.gl.getProgramParameter(program, GL.LINK_STATUS)) {\n\t\t\tvar info:String = Mammoth.gl.getProgramInfoLog(program);\n\t\t\tthrow new Exception(info, true, 'LinkProgram');\n\t\t}\n\n        // bind the attributes\n        Mammoth.gl.useProgram(program);\n        positionLoc = Mammoth.gl.getAttribLocation(program, 'position');\n        uvLoc = Mammoth.gl.getAttribLocation(program, 'uv');\n        colourLoc = Mammoth.gl.getAttribLocation(program, 'colour');\n\n        // find the uniform\n        vpLoc = Mammoth.gl.getUniformLocation(program, 'VP');\n\n        // create the texture\n        fontTexture = Mammoth.gl.createTexture();\n        Mammoth.gl.bindTexture(GL.TEXTURE_2D, fontTexture);\n\n        // temporarily create a 1x1 magenta 'loading' texture\n        Mammoth.gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, 1, 1, 0, GL.RGBA, GL.UNSIGNED_BYTE,\n              new js.html.Uint8Array([255, 0, 255, 255]));\n        textureLoc = Mammoth.gl.getUniformLocation(program, 'texture');\n\n        // load the image asynchronously\n        fontImage = js.Browser.window.document.createImageElement();\n        fontImage.addEventListener('load', function() {\n            Mammoth.gl.bindTexture(GL.TEXTURE_2D, fontTexture);\n            //Mammoth.gl.pixelStorei(GL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);\n            //Mammoth.gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, GL.RGBA, GL.UNSIGNED_BYTE, fontImage);\n            Mammoth.gl.context.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, GL.RGBA, GL.UNSIGNED_BYTE, fontImage);\n        });\n        fontImage.src = Tusk.fontTextureSrc;\n\n        // create the buffer\n        buffer = Mammoth.gl.createBuffer();\n\n        // finish up\n        Mammoth.gl.useProgram(null);\n    }\n\n    public function draw():Void {\n        Mammoth.gl.viewport(0, 0, Std.int(Mammoth.width), Std.int(Mammoth.height));\n        Mammoth.gl.scissor(0, 0, Std.int(Mammoth.width), Std.int(Mammoth.height));\n\n        Tusk.draw.screenWidth = mammoth.Mammoth.width;\n        Tusk.draw.screenHeight = mammoth.Mammoth.height;\n\n        if(Tusk.draw.numVertices == 0) return;\n        \n        Mammoth.gl.disable(GL.CULL_FACE);\n        Mammoth.gl.disable(GL.DEPTH_TEST);\n\n        Mammoth.gl.enable(GL.BLEND);\n        Mammoth.gl.blendFunc(GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA);\n\n        Mammoth.gl.useProgram(program);\n\n        Mammoth.gl.bindBuffer(GL.ARRAY_BUFFER, buffer);\n        Mammoth.gl.bufferData(GL.ARRAY_BUFFER, Tusk.draw.buffer, GL.DYNAMIC_DRAW);\n\n        Mammoth.gl.uniformMatrix4fv(vpLoc, cast(Tusk.draw.vpMatrix));\n        Mammoth.gl.uniform1i(textureLoc, 0);\n\n        Mammoth.gl.activeTexture(GL.TEXTURE0);\n        Mammoth.gl.bindTexture(GL.TEXTURE_2D, fontTexture);\n\n        Mammoth.gl.enableVertexAttribArray(positionLoc);\n        Mammoth.gl.vertexAttribPointer(positionLoc, 2, GL.FLOAT, false, 8*4, 0);\n        Mammoth.gl.enableVertexAttribArray(uvLoc);\n        Mammoth.gl.vertexAttribPointer(uvLoc, 2, GL.FLOAT, false, 8*4, 2*4);\n        Mammoth.gl.enableVertexAttribArray(colourLoc);\n        Mammoth.gl.vertexAttribPointer(colourLoc, 4, GL.FLOAT, false, 8*4, 4*4);\n\n        Mammoth.gl.drawArrays(GL.TRIANGLES, 0, Tusk.draw.numVertices);\n\n        Mammoth.gl.disableVertexAttribArray(positionLoc);\n        Mammoth.gl.disableVertexAttribArray(uvLoc);\n        Mammoth.gl.disableVertexAttribArray(colourLoc);\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.debug;\n\nimport haxe.CallStack;\nimport haxe.PosInfos;\n\nclass Exception {\n\tpublic var message(default, null):String;\n\tpublic var type(default, null):String;\n\tpublic var fatal(default, null):Bool;\n\tpublic var stack(default, null):Array<StackItem>;\n\tpublic var showStackTrace(default, null):Bool;\n\tpublic var pos(default, null):PosInfos;\n\n\tpublic function new(message:String = '', fatal:Bool = false, type:String = '', showStackTrace:Bool = true, ?pos:PosInfos) {\n\t\tthis.message = message;\n\t\tthis.fatal = fatal;\n\t\tthis.type = type;\n\t\tthis.showStackTrace = showStackTrace;\n\t\tthis.stack = CallStack.callStack();\n\t\tthis.pos = pos;\n\t}\n\n\tprivate function translateStackItem(item:StackItem):String {\n\t\treturn switch(item) {\n\t\t\tcase CFunction: \"in function\";\n\t\t\tcase Module(m): \"in module \" + m;\n\t\t\tcase FilePos(s, file, line): \"in file '\" + file + \"' at line \" + line + (s == null ? \"\" : (\": \" + translateStackItem(s)));\n\t\t\tcase Method(className, method): \"in class '\" + className + \"' in method '\" + method + \"'\";\n\t\t\tcase LocalFunction(v): \"in local function (\" + v + \")\";\n\t\t\tdefault: \"?\";\n\t\t};\n\t}\n\n\tpublic function toString():String {\n\t\tvar stackString:Array<String> = stack.map(translateStackItem);\n\t\tvar posInfo:String = pos == null ? \"\" : (\" in class: \" + pos.className + \" (\" + pos.fileName + \") in function \" + pos.methodName + \"() at line \" + pos.lineNumber);\n\t\treturn (fatal ? \"fatal \" : \"\") + type + \" exception\" + posInfo + \": \" + message + (showStackTrace ? (\"\\nstack trace:\\n  \" + stackString.join(\"\\n  \")) : '');\n\t}\n}","package mammoth.defaults;\n\nimport mammoth.types.Material;\nimport mammoth.gl.types.TShader;\nimport mammoth.gl.types.TVertexAttribute;\nimport mammoth.gl.types.TShaderUniform;\n\nclass Materials {\n    public static function shadow():Material {\n        var material:Material = new Material('shadow');\n\n        var vertexSrc:String = mammoth.macros.FileContents.contents('mammoth/assets/shadow.vert.glsl');\n        var fragSrc:String = mammoth.macros.FileContents.contents('mammoth/assets/shadow.frag.glsl');\n\n        material.setShaderSource(vertexSrc, TShader.Vertex);\n        material.setShaderSource(fragSrc, TShader.Fragment);\n        material.compile();\n\n        material.registerAttribute('position', TVertexAttribute.Vec3);\n        material.registerUniform('MVP', TShaderUniform.Matrix4);\n\n        return material;\n    }\n\n    public static function standard(directionalLights:Int, pointLights:Int):Material {\n        var material:Material = new Material('standard_${directionalLights}_${pointLights}');\n\n        var vertexSrc:String = mammoth.macros.FileContents.contents('mammoth/assets/standard.vert.glsl');\n        var fragSrc:String = mammoth.macros.FileContents.contents('mammoth/assets/standard.frag.glsl');\n\n        var vertexPre:Array<String> = new Array<String>();\n        var fragmentPre:Array<String> = new Array<String>();\n\n        if(directionalLights > 0) {\n            fragmentPre.push('#define UNIFORM_DIRECTIONAL_LIGHTS');\n            fragmentPre.push('#define NUMBER_DIRECTIONAL_LIGHTS ${directionalLights}');\n        }\n        if(pointLights > 0) {\n            fragmentPre.push('#define UNIFORM_POINT_LIGHTS');\n            fragmentPre.push('#define NUMBER_POINT_LIGHTS ${pointLights}');\n        }\n\n        vertexSrc = vertexPre.join('\\n') + '\\n' + vertexSrc;\n        fragSrc = fragmentPre.join('\\n') + '\\n' + fragSrc;\n\n        material.setShaderSource(vertexSrc, TShader.Vertex);\n        material.setShaderSource(fragSrc, TShader.Fragment);\n        material.compile();\n\n        material.registerAttribute('position', TVertexAttribute.Vec3);\n        material.registerAttribute('normal', TVertexAttribute.Vec3);\n\n        material.registerUniform('MVP', TShaderUniform.Matrix4);\n        material.registerUniform('M', TShaderUniform.Matrix4);\n\n        material.registerUniform('albedoColour', TShaderUniform.Vector3);\n        material.registerUniform('ambientColour', TShaderUniform.Vector3);\n\n        for(i in 0...directionalLights) {\n            material.registerUniform('directionalLights[${i}].direction', TShaderUniform.Vector3);\n            material.registerUniform('directionalLights[${i}].colour', TShaderUniform.Vector3);\n        }\n        for(i in 0...pointLights) {\n            material.registerUniform('pointLights[${i}].position', TShaderUniform.Vector3);\n            material.registerUniform('pointLights[${i}].colour', TShaderUniform.Vector3);\n            material.registerUniform('pointLights[${i}].distance', TShaderUniform.Float);\n        }\n\n        return material;\n    }\n}","package mammoth.macros;\n\nimport haxe.macro.Expr;\nimport haxe.io.Path;\nimport haxe.io.Bytes;\nimport haxe.crypto.Base64;\n\nclass FileContents {\n    macro public static function contents(path:String):ExprOf<String> {\n        var parts:Array<String> = path.split('/');\n        parts.insert(0, 'src');\n        #if sys\n        parts.insert(0, Sys.getCwd());\n        #end\n        var assetFilename:String = Path.join(parts);\n\n        var source:String = sys.io.File.getContent(assetFilename);\n        return macro $v{source};\n    }\n\n    macro public static function base64contents(path:String):ExprOf<String> {\n        var parts:Array<String> = path.split('/');\n        parts.insert(0, 'src');\n        #if sys\n        parts.insert(0, Sys.getCwd());\n        #end\n        var assetFilename:String = Path.join(parts);\n\n        var source:Bytes = sys.io.File.getBytes(assetFilename);\n        var srcString:String = Base64.encode(source);\n        return macro $v{srcString};\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.filetypes;\n\nimport mammoth.Log;\nimport edge.Entity;\nimport edge.IComponent;\nimport glm.Vec2;\nimport glm.Mat4;\n\nimport mammoth.Mammoth;\nimport mammoth.components.Camera;\nimport mammoth.components.DirectionalLight;\nimport mammoth.components.PointLight;\nimport mammoth.components.MeshRenderer;\nimport mammoth.components.Transform;\nimport mammoth.defaults.Materials;\nimport mammoth.types.Colour;\nimport mammoth.types.MaterialData;\nimport mammoth.types.Mesh;\nimport mammoth.types.Material;\nimport mammoth.gl.types.TUniformData;\nimport mammoth.gl.types.TVertexAttribute;\n\nimport haxe.io.Bytes;\nimport haxe.crypto.Base64;\nimport haxe.ds.StringMap;\n\nusing StringTools;\n\n@:enum\nabstract MammothCameraType(String) {\n\tvar Orthographic = \"orthographic\";\n\tvar Perspective = \"perspective\";\n}\n\ntypedef MammothCamera = {\n    var name:String;\n    var type:MammothCameraType;\n    var near:Float;\n    var far:Float;\n    var clearColour:Colour;\n    @:optional var aspect:Float;\n    @:optional var fov:Float;\n    @:optional var ortho_size:Float;\n}\n\n@:enum\nabstract MammothLightType(String) {\n\tvar Directional = \"directional\";\n\tvar Point = \"point\";\n}\n\ntypedef MammothLight = {\n    var name:String;\n    var type:MammothLightType;\n    var colour:Colour;\n    @:optional var distance:Float;\n}\n\ntypedef MammothUnlitShader = {\n    var colour:Colour;\n}\n\ntypedef MammothDiffuseShader = {\n    var ambient:Colour;\n    var colour:Colour;\n}\n\ntypedef MammothShader = {\n    var name:String;\n    var textures:Array<String>;\n    @:optional var unlit:MammothUnlitShader;\n    @:optional var diffuse:MammothDiffuseShader;\n}\n\ntypedef MammothMesh = {\n    var name:String;\n    var vertices:String;\n    var vlayout:Array<String>;\n    var indices:String;\n}\n\ntypedef MammothTransform = {\n    var translation:Array<Float>;\n    var rotation:Array<Float>;\n    var scale:Array<Float>;\n}\n\ntypedef MammothRender = {\n    var mesh:String;\n    @:optional var shader:String;\n}\n\ntypedef MammothObject = {\n    var name:String;\n    @:optional var children:Array<MammothObject>;\n    @:optional var transform:MammothTransform;\n    @:optional var components:Dynamic;\n    @:optional var render:MammothRender;\n    @:optional var camera:String;\n    @:optional var light:String;\n}\n\ntypedef MammothMeta = {\n    var version:String;\n    @:optional var file:String;\n    @:optional var blender:String;\n}\n\ntypedef MammothFile = {\n    var meta:MammothMeta;\n    \n    var cameras:Array<MammothCamera>;\n    var lights:Array<MammothLight>;\n    var shaders:Array<MammothShader>;\n    var meshes:Array<MammothMesh>;\n    var objects:Array<MammothObject>;\n}\n\nclass MammothJSON {\n    private static var cameras:StringMap<Camera> = new StringMap<Camera>();\n    private static var lights:StringMap<IComponent> = new StringMap<IComponent>();\n    private static var materialDatas:StringMap<MaterialData> = new StringMap<MaterialData>();\n    \n    private function new(){}\n\n    private static function loadCamera(cam:MammothCamera):Void {\n        var camera:Camera = new Camera();\n        camera.setNearFar(cam.near, cam.far);\n        camera.setClearColour(cam.clearColour);\n        camera.setProjection(switch(cam.type) {\n            case MammothCameraType.Orthographic:\n                ProjectionMode.Orthographic(cam.ortho_size);\n            case MammothCameraType.Perspective:\n                ProjectionMode.Perspective(cam.fov);\n        });\n        camera.setViewport(new Vec2(0, 0), new Vec2(1, 1));\n        cameras.set(cam.name, camera);\n    }\n\n    private static function loadLight(light:MammothLight):Void {\n        lights.set(light.name, switch(light.type) {\n            case MammothLightType.Directional: {\n                var dirLight:DirectionalLight = new DirectionalLight();\n                dirLight.setColour(light.colour);\n                dirLight;\n            }\n            case MammothLightType.Point: {\n                var pointLight:PointLight = new PointLight();\n                pointLight.setColour(light.colour);\n                pointLight.setDistance(Math.sqrt(light.distance));\n                pointLight;\n            }\n        });\n    }\n\n    private static function loadMaterialData(shader:MammothShader):Void {\n        var data:MaterialData = new MaterialData();\n\n        if(shader.unlit != null) {\n            data.set('albedoColour', TUniformData.RGB(shader.unlit.colour));\n        }\n        else if(shader.diffuse != null) {\n            data.set('albedoColour', TUniformData.RGB(shader.diffuse.colour));\n            data.set('ambientColour', TUniformData.RGB(shader.diffuse.ambient));\n        }\n\n        // TODO: textures\n\n        materialDatas.set(shader.name, data);\n    }\n\n    private static function loadMesh(meshData:MammothMesh):Void {\n        var mesh:Mesh = new Mesh(meshData.name);\n\n        mesh.setVertexData(parseFloatArrayURI(meshData.vertices));\n        mesh.setIndexData(parseIntArrayURI(meshData.indices));\n\n        for(attribute in meshData.vlayout) {\n            mesh.registerAttribute(attribute, switch(attribute) {\n                case 'position': TVertexAttribute.Vec3;\n                case 'normal': TVertexAttribute.Vec3;\n                case 'colour': TVertexAttribute.Vec4;\n                case 'uv': TVertexAttribute.Vec2;\n                case _: null;\n            });\n        }\n\n        mesh.compile();\n        //meshes.set(meshData.name, mesh);\n        Mammoth.resources.meshes.set(meshData.name, mesh);\n    }\n\n    private static function loadObject(parentTransform:Transform, object:MammothObject):Void {\n        var entity:Entity = Mammoth.engine.create([]);\n        if(object.transform != null) {\n            var transform:Transform = new Transform();\n            transform.position = cast(object.transform.translation);\n            transform.rotation = cast(object.transform.rotation);\n            transform.scale = cast(object.transform.scale);\n            transform.name = object.name;\n            transform.parent = parentTransform;\n\n            // load all children recursively\n            if(object.children != null) {\n                for(child in object.children) {\n                    loadObject(transform, child);\n                }\n            }\n\n            entity.add(transform);\n        }\n\n        if(object.render != null && object.render.shader != null) {\n            var renderer:MeshRenderer = new MeshRenderer();\n            \n            renderer.mesh = Mammoth.resources.meshes.get(object.render.mesh);\n            if(!Mammoth.resources.materials.exists('standard_1_0')) {\n                Mammoth.resources.materials.set('standard_1_0', Materials.standard(1, 0));\n            }\n            renderer.material = Mammoth.resources.materials.get('standard_1_0');\n            renderer.materialData = materialDatas.get(object.render.shader);\n\n            entity.add(renderer);\n        }\n\n        if(object.camera != null) {\n            entity.add(cameras.get(object.camera));\n        }\n\n        if(object.light != null) {\n            entity.add(lights.get(object.light));\n        }\n    }\n\n    public static function load(file:MammothFile):Void {\n        Log.info('Loading data from ${file.meta.file}..');\n\n        // load cameras\n        cameras = new StringMap<Camera>();\n        for(camera in file.cameras) {\n            loadCamera(camera);\n        }\n\n        // load lights\n        lights = new StringMap<edge.IComponent>();\n        for(light in file.lights) {\n            loadLight(light);\n        }\n\n        // load shaders\n        materialDatas = new StringMap<MaterialData>();\n        for(shad in file.shaders) {\n            loadMaterialData(shad);\n        }\n\n        // load meshes\n        for(me in file.meshes) {\n            loadMesh(me);\n        }\n        \n        // load actual objects\n        for(object in file.objects) {\n            loadObject(null, object);\n        }\n    }\n\n    private static function parseFloatArrayURI(uri:String):Array<Float> {\n        if(!uri.startsWith('data:text/plain;base64,')) {\n            return new Array<Float>();\n        }\n\n        var data:Bytes = Base64.decode(uri.substr('data:text/plain;base64,'.length));\n        var arr:haxe.io.Float32Array = haxe.io.Float32Array.fromBytes(data);\n\n        var ret:Array<Float> = new Array<Float>();\n        for(i in 0...arr.length) {\n            ret.push(arr.get(i));\n        }\n        return ret;\n    }\n\n    private static function parseIntArrayURI(uri:String):Array<Int> {\n        if(!uri.startsWith('data:text/plain;base64,')) {\n            return new Array<Int>();\n        }\n\n        var data:Bytes = Base64.decode(uri.substr('data:text/plain;base64,'.length));\n        var arr:haxe.io.Int32Array = haxe.io.Int32Array.fromBytes(data);\n\n        var ret:Array<Int> = new Array<Int>();\n        for(i in 0...arr.length) {\n            ret.push(arr.get(i));\n        }\n        return ret;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.systems;\n\nimport edge.ISystem;\nimport mammoth.components.Transform;\nimport mammoth.components.Camera;\nimport glm.GLM;\n\nusing glm.Mat4;\n\nclass CameraSystem implements ISystem {\n    public function update(transform:Transform, camera:Camera) {\n        // calculate the updated model matrix\n        camera.v = transform.m.copy(camera.v);\n        camera.v.invert(camera.v);\n\n        // check for aspect ratio changes\n        var aspect:Float = Mammoth.aspectRatio;\n        /*if(aspect != camera.aspect) {\n            camera.pDirty = true;\n        }*/\n        camera.pDirty = true;\n\n        if(camera.pDirty) {\n            camera.p = switch (camera.projection) {\n                case ProjectionMode.Perspective(fov): GLM.perspective(fov, aspect, camera.near, camera.far, camera.p);\n                case ProjectionMode.Orthographic(size): {\n                    var halfX:Float = size * 0.5;\n                    var halfY:Float = halfX / aspect;\n                    GLM.orthographic(-halfX, halfX, -halfY, halfY, camera.near, camera.far, camera.p);\n                }\n            };\n\n            camera.vp = Mat4.multMat(camera.p, camera.v, camera.vp);\n            camera.pDirty = false;\n        }\n    }\n}\n\n","package edge.core.macro;\n\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.ExprTools;\nimport haxe.macro.Type;\nusing haxe.macro.TypeTools;\nusing thx.macro.MacroFields;\nimport edge.core.macro.Macros.*;\n\nclass BuildSystem {\n  public inline static var PROCESS_SUFFIX = \"_SystemProcess\";\n\n  macro public static function complete() : Array<Field> {\n    var fields = Context.getBuildFields(),\n        type = Context.getLocalClass().get();\n    checkUpdate(fields);\n    injectToString(type, fields);\n    injectConstructor(type, fields);\n    makePublic(fields, \"engine\");\n    makePublic(fields, \"entity\");\n    makePublic(fields, \"timeDelta\");\n    makePublic(fields, \"before\");\n    injectSystemProcess(fields, Context.getLocalClass());\n    return fields;\n  }\n\n  static function injectSystemProcess(fields : Array<Field>, cls : Ref<ClassType>) {\n    var system = cls.toString(),\n        process = '$system${PROCESS_SUFFIX}';\n\n    BuildSystemProcess.createProcessType(system, process, fields);\n\n    fields.push(createVarField(\"__process__\", macro : edge.core.ISystemProcess));\n\n    appendExprToFieldFunction(\n      findField(fields, \"new\"),\n      Context.parse('__process__ = new $process(this)', Context.currentPos())\n    );\n  }\n\n  static function injectToString(type : ClassType, fields : Array<Field>) {\n    if(isFieldInHirearchy(type, \"toString\")) return;\n    var cls = clsName();\n    fields.push(createFunctionField(\"toString\", macro : String, macro return $v{cls}));\n  }\n\n  static function injectConstructor(type : ClassType, fields : Array<Field>) {\n    if(hasField(fields, \"new\")) return;\n    fields.push(createFunctionField(\n      \"new\",\n      isFieldInHirearchy(type, \"new\") ? macro super() : macro {}\n    ));\n  }\n\n  static function checkUpdate(fields : Array<Field>) {\n    var field = findField(fields, \"update\");\n    if(field == null)\n      Context.error('${clsName()} doesn\\'t contain a method `update`', Context.currentPos());\n    if(!field.isPublic())\n      field.access.push(APublic);\n    if(field.isStatic())\n      Context.error('${clsName()}.update() cannot be static', Context.currentPos());\n    if(!field.isMethod())\n      Context.error('${clsName()}.update() must be method', Context.currentPos());\n    switch field.kind {\n      case FFun(f):\n        for(arg in f.args) {\n          switch arg.type {\n            case TPath(p):\n              if(p.params.length > 0)\n                Context.error('argument `${arg.name}` of ${clsName()}.update() cannot have type parameters', Context.currentPos());\n              var t = Context.getType(p.name).follow();\n              switch t {\n                case TInst(s, _) if(s.toString() != \"String\"):\n                  // TODO, should we support enums?\n                case _:\n                  Context.error('argument `${arg.name}` of ${clsName()}.update() is not a class instance', Context.currentPos());\n              }\n            case _:\n              Context.error('argument `${arg.name}` of ${clsName()}.update() is not a class instance', Context.currentPos());\n          }\n        }\n        var ret = f.ret;\n        if(null == ret) {\n          ret = macro : Void;\n        }\n        switch ret {\n          case macro : Void: // change return type to Bool\n            var exprs = [\n                  changeReturnFromVoidToBool(f.expr),\n                  macro return true\n                ];\n            f.expr = macro $b{exprs};\n            f.ret = macro : Bool;\n          case macro : Bool: // you are good to go\n          case _: Context.error('${clsName()}.update() return type is invalid: ${ret}', Context.currentPos());\n        }\n      case _:\n    }\n    if(!fieldHasMeta(field, \":keep\"))\n      field.meta.push({ name : \":keep\", pos : Context.currentPos() });\n  }\n\n  static function changeReturnFromVoidToBool(expr) {\n    return ExprTools.map(expr, function(e) {\n      switch e.expr {\n        case EReturn(v) if(v == null):\n          return macro return true;\n        case EReturn(v):\n          return e;\n        case ex:\n          return changeReturnFromVoidToBool(e);\n        };\n    });\n  }\n}\n","package edge.core.macro;\n\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nusing haxe.macro.TypeTools;\nusing thx.macro.MacroFields;\nimport Type in RType;\n\nclass Macros {\n  public static function getVarAsFunctionArgs(fields : Array<Field>) : Array<FunctionArg> {\n    return fields\n      .map(function(field) return switch field.kind {\n        case FVar(t, _) if(!field.isStatic()):\n          { name : field.name, type : t, opt : null, value : null, meta : null }\n        case _:\n          null;\n      })\n      .filter(function(field) return field != null);\n  }\n  \n  public static function getClassVarAsFunctionArgs(fields : Array<ClassField>) : Array<FunctionArg> {\n    return fields\n      .map(function(field) return switch field.kind {\n        case FVar(t, _):\n          { name : field.name, type : field.type.follow().toComplexType(), opt : null, value : null, meta : null }\n        case _:\n          null;\n      })\n      .filter(function(field) return field != null);\n  }\n\n  public static function createVarField(name : String, type : ComplexType) : Field {\n    return {\n      name: name,\n      kind: FVar(type, null),\n      pos: Context.currentPos()\n    };\n  }\n\n  public static function createFunctionField(name : String, ?args : Array<FunctionArg>, ?ret : ComplexType, ?expr : Expr, ?access : Array<Access>) : Field {\n    return {\n      name: name,\n      access: null != access ? access : [APublic],\n      kind: FFun({\n        ret  : null != ret ? ret : macro : Void,\n        expr : null != expr ? expr : macro {},\n        args : null != args ? args : []\n      }),\n      pos: Context.currentPos()\n    };\n  }\n\n  public static function makeVarsPublic(fields : Array<Field>) {\n    fields.map(function(field) switch field.kind {\n      case FVar(_, _) if(!field.isPublic()):\n        field.access.push(APublic);\n      case _:\n    });\n  }\n\n  public static function makePublic(fields : Array<Field>, name : String) {\n    var field = findField(fields, name);\n    if(null == field) return;\n    makeFieldPublic(field);\n  }\n\n  public static function makeFieldPublic(field : Field) {\n    if(isPublic(field)) return;\n    field.access.push(APublic);\n  }\n\n  public static function isPublic(field : Field) {\n    for(a in field.access)\n      if(RType.enumEq(a, APublic))\n        return true;\n    return false;\n  }\n\n  public static function hasField(fields : Array<Field>, name : String)\n    return null != findField(fields, name);\n\n  public static function findField(fields : Array<Field>, name : String) {\n    for(field in fields)\n      if(field.name == name)\n        return field;\n    return null;\n  }\n\n  public static function findClassField(fields : Array<ClassField>, name : String) {\n    for(field in fields) {\n      if(field.name == name)\n        return field;\n    }\n    return null;\n  }\n\n  public static function hasClassField(fields : Array<ClassField>, name : String)\n    return findClassField(fields, name) != null;\n\n  public static function isFieldInHirearchy(type : ClassType, name : String) : Bool {\n    if(name == \"new\") {\n      if(null != type.constructor)\n        return true;\n    } else {\n      if(hasClassField(type.fields.get(), name))\n        return true;\n    }\n    var superClass = type.superClass;\n    if(null == superClass) {\n      return false;\n    }\n    return isFieldInHirearchy(superClass.t.get(), name);\n  }\n\n  public static function hasVarField(fields : Array<Field>, fieldName : String) {\n    for(field in fields)\n      if(field.name == fieldName && switch field.kind {\n        case FVar(_, _): true;\n        case _: false;\n      })\n        return true;\n    return false;\n  }\n\n  public static function hasFunField(fields : Array<Field>, fieldName : String) {\n    for(field in fields)\n      if(field.name == fieldName && switch field.kind {\n        case FFun(_): true;\n        case _: false;\n      })\n        return true;\n    return false;\n  }\n\n  public static function fieldHasMeta(field : Field, name : String) {\n    if(field.meta == null) return false;\n    for(meta in field.meta)\n      if(meta.name == name)\n        return true;\n    return false;\n  }\n\n  inline public static function clsName()\n    return Context.getLocalClass().toString();\n\n  public static function appendExprToFieldFunction(field : Field, expr : Expr) {\n    switch field.kind {\n      case FFun(o):\n        var exprs = [o.expr, expr];\n        o.expr = macro $b{exprs};\n      case _:\n    }\n  }\n\n  public static function fieldFunctionHasArguments(field : Field) {\n    switch field.kind {\n      case FFun(o):\n        return o.args.length > 0;\n      case _:\n        return false;\n    }\n  }\n\n  public static function fieldFunctionArguments(field : Field) {\n    switch field.kind {\n      case FFun(o):\n        return o.args;\n      case _:\n        return null;\n    }\n  }\n\n  public static function getAncestor(type : ClassType):Null<ClassType>\n  {\n    var c = type.superClass;\n    if (c == null) return null;\n\n    return c.t.get();\n  }\n}\n","package edge.core.macro;\n\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nusing haxe.macro.ComplexTypeTools;\nusing haxe.macro.TypeTools;\nimport edge.core.macro.Macros.*;\n\nclass BuildSystemProcess {\n  public static function createProcessType(systemName : String, processName : String, systemFields : Array<Field>) {\n    var pack = processName.split('.'),\n        name = pack.pop(),\n        type = Context.getType(systemName),\n        system = type.toComplexType(),\n        classType = switch type { case TInst(cls, _): cls.get(); case _: null; },\n        fields = [],\n        kind = TDClass(\n          null,\n          [{ pack : ['edge', 'core'], name : 'ISystemProcess' }],\n          false\n        );\n\n    injectConstructor(system, fields);\n    injectRemoveEntity(fields);\n    injectAddEntity(fields);\n    injectSystemField(system, fields);\n    injectUpdate(classType, systemFields, fields);\n    injectViews(systemFields, fields);\n    injectUpdateMatchRequirements(systemFields, fields);\n\n    Context.defineType({\n      pos : Context.currentPos(),\n      pack : pack,\n      name : name,\n      meta : [{\n          pos : Context.currentPos(),\n          name : \":access\",\n          params : [macro edge.View]\n        }],\n      kind : kind,\n      fields : fields\n    });\n  }\n\n  static function injectViews(systemFields : Array<Field>, fields : Array<Field>)\n    for(field in collectViewFields(systemFields))\n      injectView(field, systemFields, fields);\n\n  static function injectView(info : { name : String, types : Array<Field>, field : Field }, systemFields : Array<Field>, fields : Array<Field>) {\n    var name = info.name;\n    makeFieldPublic(info.field);\n    appendExprToFieldFunction(\n      findField(fields, \"new\"),\n      Context.parse('system.$name = new edge.View()', Context.currentPos())\n    );\n\n    injectViewMatchRequirements(info, systemFields, fields);\n  }\n\n  static function injectViewMatchRequirements(info : { name : String, types : Array<Field>, field : Field }, systemFields : Array<Field>, fields : Array<Field>) {\n    var name   = info.name,\n        types  = info.types,\n        sexprs = [];\n\n    sexprs.push('var removed = system.$name.tryRemove(entity)');\n    sexprs.push('var count = ' + types.length);\n    sexprs.push('var o : {' +\n      types.map(function(type) {\n          return type.name + \" : \" + switch type.kind {\n            case FVar(t, _): Context.follow(t.toType()).toComplexType().toString();\n            case _: \"\";\n          };\n        }).join(\", \") +\n      '} = {' +\n      types.map(function(type) return '${type.name} : null').join(\", \") + '}');\n    var expr = 'for(component in entity.components()) {\\n';\n    for(type in types) {\n      var t = switch type.kind {\n          case FVar(t, _): Context.follow(t.toType()).toComplexType().toString();\n          case _: \"\";\n        };\n      expr += '  if(Std.is(component, $t)) {\\n';\n      expr += '    o.${type.name} = cast component;\\n';\n      expr += '    if(--count == 0) break; else continue;\\n';\n      expr += '  }\\n';\n    }\n    expr += '}';\n    sexprs.push(expr);\n    sexprs.push('var added = count == 0 && system.$name.tryAdd(entity, o)');\n\n    if(hasFunField(systemFields, '${name}Removed')) {\n      sexprs.push('if((null != removed) && !added) system.${name}Removed(entity, removed)');\n    }\n    if(hasFunField(systemFields, '${name}Added')) {\n      sexprs.push('if(added && (null == removed)) system.${name}Added(entity, o)');\n    }\n\n    var exprs = sexprs.map(function(sexpr) return Context.parse(sexpr, Context.currentPos())),\n        methodName = '${name}MatchRequirements';\n    fields.push(createFunctionField(\n        methodName,\n        [{ name : \"entity\", type : macro : edge.Entity }],\n        macro $b{exprs}\n      ));\n\n    appendExprToFieldFunction(\n      findField(fields, \"addEntity\"),\n      Context.parse('$methodName(entity)', Context.currentPos())\n    );\n\n    expr = hasFunField(systemFields, '${name}Removed') ?\n      '{ var removed = system.$name.tryRemove(entity); if(removed != null) system.${name}Removed(entity, removed); }' :\n      'system.$name.tryRemove(entity)';\n    appendExprToFieldFunction(\n      findField(fields, \"removeEntity\"),\n      Context.parse(expr, Context.currentPos())\n    );\n  }\n\n  static function injectUpdate(systemType : ClassType, systemFields : Array<Field>, fields : Array<Field>) {\n    var exprs = [];\n    if(hasVarField(systemFields, \"engine\"))\n      exprs.push(macro system.engine = engine);\n    if(hasVarField(systemFields, \"timeDelta\"))\n      exprs.push(macro system.timeDelta = delta);\n\n    var update = findField(systemFields, \"update\"),\n        constructor = findField(fields, \"new\");\n\n    exprs.push(macro var result = true);\n    if(fieldFunctionHasArguments(update)) {\n      var args = fieldFunctionArguments(update),\n          fieldTypes = args.map(function(arg) : Field {\n              var t = Context.follow(arg.type.toType()).toComplexType(),\n                  kind : FieldType = FVar(t, null);\n              return {\n                pos  : Context.currentPos(),\n                name : arg.name,\n                kind : kind\n              };\n            }),\n          type = TPath({\n              pack : [\"edge\"],\n              name : \"View\",\n              params : [TPType(TAnonymous(fieldTypes))]\n            });\n      fields.push(createVarField(\"updateItems\", type));\n\n      var expr = hasFunField(systemFields, 'updateRemoved') ?\n        '{ var removed = updateItems.tryRemove(entity); if(removed != null) system.updateRemoved(entity, removed); }' :\n        'updateItems.tryRemove(entity)';\n      appendExprToFieldFunction(\n        findField(fields, \"removeEntity\"),\n        Context.parse(expr, Context.currentPos())\n      );\n\n      appendExprToFieldFunction(\n        constructor,\n        macro updateItems = new edge.View()\n      );\n\n      if(hasFunField(systemFields, \"before\") || isFieldInHirearchy(systemType, \"before\"))\n        exprs.push(macro if(updateItems.count > 0) system.before());\n      // create loop expression\n      exprs.push(macro var data);\n      var expr = '\\nfor(item in updateItems) {\\n';\n      // set entity if required\n      if(hasVarField(systemFields, \"entity\"))\n        expr += '  system.entity = item.entity;\\n';\n      // call update\n      expr += '  data = item.data;\\n';\n      expr += '  result = system.update(' + args.map(function(arg) {\n          return 'data.${arg.name}';\n        }).join(\", \") + ');\\n';\n      expr += '  if(!result) break;';\n      expr += '}';\n      exprs.push(Context.parse(expr, Context.currentPos()));\n    } else {\n      if(hasFunField(systemFields, \"before\") || isFieldInHirearchy(systemType, \"before\"))\n        exprs.push(macro system.before());\n      exprs.push(macro result = system.update());\n    }\n    if(hasFunField(systemFields, \"after\") || isFieldInHirearchy(systemType, \"after\"))\n      exprs.push(macro system.after());\n    exprs.push(macro return result);\n\n    //trace(haxe.macro.ExprTools.toString(macro $b{exprs}));\n\n    fields.push(createFunctionField(\n        \"update\",\n        [{ name : \"engine\", type : macro : edge.Engine },\n         { name : \"delta\", type : macro : Float }],\n        macro : Bool,\n        macro $b{exprs}\n      ));\n  }\n\n  static function injectUpdateMatchRequirements(systemFields : Array<Field>, fields : Array<Field>) {\n    var args = fieldFunctionArguments(findField(systemFields, \"update\"));\n    if(args.length == 0) return;\n\n    var sexprs = [];\n    sexprs.push('var removed = updateItems.tryRemove(entity)');\n    sexprs.push('var count = ' + args.length);\n    sexprs.push('var o : {' + args.map(function(arg) return '${arg.name} : ${Context.follow(arg.type.toType()).toComplexType().toString()}').join(\", \") + '} = {' + args.map(function(arg) return '${arg.name} : null').join(\", \") + '}');\n\n    var expr = 'for(component in entity.components()) {\\n';\n    for(arg in args) {\n      var t = Context.follow(arg.type.toType()).toComplexType().toString();\n      expr += '  if(Std.is(component, $t)) {\\n';\n      expr += '    o.${arg.name} = cast component;\\n';\n      expr += '    if(--count == 0) break; else continue;\\n';\n      expr += '  }\\n';\n    }\n    expr += '}';\n    sexprs.push(expr);\n\n    sexprs.push('var added = count == 0 && updateItems.tryAdd(entity, o)');\n\n    if(hasFunField(systemFields, 'updateRemoved')) {\n      sexprs.push('if((null != removed) && !added) system.updateRemoved(entity, removed)');\n    }\n    if(hasFunField(systemFields, 'updateAdded')) {\n      sexprs.push('if(added && (null == removed)) system.updateAdded(entity, o)');\n    }\n\n    var exprs = sexprs.map(function(sexpr) return Context.parse(sexpr, Context.currentPos()));\n    fields.push(createFunctionField(\n        \"updateMatchRequirements\",\n        [{ name : \"entity\", type : macro : edge.Entity }],\n        macro $b{exprs}\n      ));\n\n    appendExprToFieldFunction(\n      findField(fields, \"addEntity\"),\n      macro updateMatchRequirements(entity));\n  }\n\n  static function injectRemoveEntity(fields : Array<Field>)\n    fields.push(createFunctionField(\n        \"removeEntity\",\n        [{ name : \"entity\", type : macro : edge.Entity }]\n      ));\n\n  static function injectAddEntity(fields : Array<Field>)\n    fields.push(createFunctionField(\n        \"addEntity\",\n        [{ name : \"entity\", type : macro : edge.Entity }]\n      ));\n\n  static function injectSystemField(system : ComplexType, fields : Array<Field>)\n    fields.push(createVarField(\"system\", system));\n\n  static function injectConstructor(system : ComplexType, fields : Array<Field>)\n    fields.push(createFunctionField(\n        \"new\",\n        [{ name : \"system\", type : system }],\n        macro this.system = system\n      ));\n\n  static function collectViewFields(fields : Array<Field>) : Array<{ name : String, types : Array<Field>, field : Field }> {\n    var results = [];\n    for(field in fields) {\n      switch field.kind {\n        case FVar(tp, _):\n          if(tp == null) continue;\n          tp = Context.follow(tp.toType()).toComplexType();\n          switch tp {\n            case TPath({ name : \"View\", pack : [\"edge\"], params : [TPType(TAnonymous(p))] }):\n              results.push({\n                name  : field.name,\n                types : p,\n                field : field\n              });\n            case _:\n          };\n        case _:\n      }\n    }\n    return results;\n  }\n}\n","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.systems;\n\nimport edge.ISystem;\nimport mammoth.components.Transform;\nimport mammoth.components.DirectionalLight;\n\nclass DirectionalLightSystem implements ISystem {\n    private static var zDir:Vec4 = new Vec4(0, 0, 1, 1);\n    \n    public function update(transform:Transform, light:DirectionalLight) {\n        transform.m.multVec(zDir, light.direction);\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.systems;\n\nimport mammoth.gl.AttributeLocation;\nimport mammoth.types.Mesh;\nimport edge.ISystem;\nimport edge.View;\nimport mammoth.components.MeshRenderer;\nimport mammoth.components.Transform;\nimport mammoth.components.DirectionalLight;\nimport mammoth.types.Material;\nimport mammoth.gl.GL;\nimport mammoth.defaults.Materials;\nimport mammoth.gl.types.TCullMode;\nimport mammoth.gl.types.TDepthFunction;\nimport mammoth.defaults.Colours;\n\nclass DirectionalShadowSystem implements ISystem {\n    private var viewMatrix:Mat4 = Mat4.identity(new Mat4());\n    private var projectionMatrix:Mat4 = Mat4.identity(new Mat4());\n    private var viewProjectionMatrix:Mat4 = Mat4.identity(new Mat4());\n    private var MVP:Mat4 = Mat4.identity(new Mat4());\n    private var shadowMaterial:Material;\n\n    var shadowCasters:View<{ transform:Transform, renderer:MeshRenderer }>;\n\n    public function update(transform:Transform, light:DirectionalLight) {\n        // create a shadow material if one doesn't exist yet\n        if(shadowMaterial == null) {\n            shadowMaterial = Materials.shadow();\n        }\n\n        // create a framebuffer if one doesn't exist yet\n        if(light.shadowFramebuffer == null) {\n            // create the framebuffer\n            light.shadowFramebuffer = Mammoth.gl.createFramebuffer();\n        }\n\n        // switch to the framebuffer\n        Mammoth.gl.bindFramebuffer(GL.FRAMEBUFFER, light.shadowFramebuffer);\n\n        // give the framebuffer a colour image\n        if(light.colourmap == null) {\n            light.colourmap = Mammoth.gl.createTexture();\n            Mammoth.gl.bindTexture(GL.TEXTURE_2D, light.colourmap);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);\n            Mammoth.gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, 1024, 1024, 0, GL.RGBA, GL.UNSIGNED_BYTE, null);\n            Mammoth.gl.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, light.colourmap, 0);\n        }\n\n        // give the framebuffer a depth image\n        if(light.shadowmap == null) {\n            light.shadowmap = Mammoth.gl.createTexture();\n            Mammoth.gl.bindTexture(GL.TEXTURE_2D, light.shadowmap);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);\n            Mammoth.gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);\n            Mammoth.gl.texImage2D(GL.TEXTURE_2D, 0, GL.DEPTH_COMPONENT, 1024, 1024, 0, GL.DEPTH_COMPONENT, GL.UNSIGNED_SHORT, null);\n            Mammoth.gl.framebufferTexture2D(GL.FRAMEBUFFER, GL.DEPTH_ATTACHMENT, GL.TEXTURE_2D, light.shadowmap, 0);\n        }\n\n        if(Mammoth.gl.checkFramebufferStatus(GL.FRAMEBUFFER) != GL.FRAMEBUFFER_COMPLETE) {\n            Log.error('Framebuffer isn\\'t complete!');\n        }\n\n        // calculate the VP matrix for the light\n        // TODO: calculate this smarter\n        GLM.orthographic(-10, 10, -10, 10, -10, 20, projectionMatrix);\n        transform.m.invert(viewMatrix);\n        Mat4.multMat(projectionMatrix, viewMatrix, viewProjectionMatrix);\n\n        // render to the framebuffer!\n        Mammoth.gl.viewport(0, 0, 1024, 1024);\n        Mammoth.gl.scissor(0, 0, 1024, 1024);\n        Mammoth.gl.clearColor(Colours.Black);\n        Mammoth.gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n\n        // setup the state\n        Mammoth.gl.enable(GL.CULL_FACE);\n        Mammoth.gl.cullFace(cast(TCullMode.Back));\n        Mammoth.gl.depthMask(true);\n        Mammoth.gl.enable(GL.DEPTH_TEST);\n        Mammoth.gl.depthFunc(cast(TDepthFunction.LessOrEqual));\n\n        // use our shadow program\n        Mammoth.gl.useProgram(shadowMaterial.program);\n        Mammoth.gl.uniformMatrix4fv(shadowMaterial.uniformLocation('MVP'), cast(MVP));\n\n        // get the position location\n        var positionLocation:AttributeLocation = shadowMaterial.attributeLocation('position');\n        Mammoth.gl.enableVertexAttribArray(positionLocation);\n\n        // now actually render\n        for(shadowCaster in shadowCasters) {\n            // cache the things we care about\n            var transform:Transform = shadowCaster.data.transform;\n            var renderer:MeshRenderer = shadowCaster.data.renderer;\n            var mesh:Mesh = renderer.mesh;\n\n            // skip any meshes that doesn't have position data which is the minimum that we need!\n            if(!mesh.hasAttribute('position')) {\n                continue;\n            }\n\n            // calculate the MVP!\n            Mat4.multMat(viewProjectionMatrix, transform.m, MVP);\n\n            // setup the vertex attribution pointer!\n            var positionAttribute = mesh.getAttribute('position');\n            Mammoth.gl.vertexAttribPointer(positionLocation, 3, GL.FLOAT, false, positionAttribute.stride, positionAttribute.offset);\n\n            // bind the index buffer to the vertices for triangles\n            Mammoth.gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);\n\n            // and draw those suckers!\n            Mammoth.gl.drawElements(GL.TRIANGLES, mesh.indexCount, GL.UNSIGNED_SHORT, 0);\n            Mammoth.stats.drawCalls++;\n            Mammoth.stats.triangles += Std.int(mesh.indexCount / 3);\n        }\n\n        // re-disable vertex attrib array\n        Mammoth.gl.disableVertexAttribArray(positionLocation);\n\n        // switch back to the main framebuffer\n        Mammoth.gl.bindFramebuffer(GL.FRAMEBUFFER, null);\n    }\n}\n\n","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.systems;\n\nimport edge.ISystem;\nimport glm.GLM;\nimport glm.Quat;\nimport glm.Vec3;\nimport glm.Mat4;\nimport mammoth.components.Transform;\n\nclass ModelMatrixSystem implements ISystem {\n    private var position:Vec3 = new Vec3();\n    private var rotation:Quat = new Quat();\n    private var scale:Vec3 = new Vec3();\n\n    private function calculateModelMatrix(transform:Transform) {\n        // interpolate based on timing\n        Vec3.lerp(transform.lastPosition, transform.position, Mammoth.timing.alpha, position);\n        Quat.slerp(transform.lastRotation, transform.rotation, Mammoth.timing.alpha, rotation);\n        Vec3.lerp(transform.lastScale, transform.scale, Mammoth.timing.alpha, scale);\n\n        // calculate the full transformation matrix\n        GLM.transform(position, rotation, scale, transform.m);\n\n        if(transform.parent != null) {\n            calculateModelMatrix(transform.parent);\n            Mat4.multMat(transform.parent.m, transform.m, transform.m);\n        }\n    }\n\n    public function update(transform:Transform) {\n        calculateModelMatrix(transform);\n    }\n}\n\n","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage glm;\n\nimport glm.GLM.FloatArray;\n\n/**\n *  A quaternion\n */\nabstract Quat(FloatArray) {\n    /**\n     *  Accessor utility for the first element of the quaternion\n     */\n    public var x(get, set):Float;\n    private inline function get_x():Float return this[0];\n    private inline function set_x(v:Float):Float return this[0] = v;\n\n    /**\n     *  Accessor utility for the second element of the quaternion\n     */\n    public var y(get, set):Float;\n    private inline function get_y():Float return this[1];\n    private inline function set_y(v:Float):Float return this[1] = v;\n\n    /**\n     *  Accessor utility for the third element of the quaternion\n     */\n    public var z(get, set):Float;\n    private inline function get_z():Float return this[2];\n    private inline function set_z(v:Float):Float return this[2] = v;\n\n    /**\n     *  Accessor utility for the fourth element of the quaternion\n     */\n    public var w(get, set):Float;\n    private inline function get_w():Float return this[3];\n    private inline function set_w(v:Float):Float return this[3] = v;\n\n\t@:arrayAccess\n\tpublic inline function get(key:Int) {\n\t\treturn this[key];\n\t}\n\n\t@:arrayAccess\n\tpublic inline function arrayWrite(key:Int, value:Float):Float {\n\t\treturn this[key] = value;\n\t}\n\n    public inline function new(x:Float = 0, y:Float = 0, z:Float = 0, w:Float = 1) {\n        this = new FloatArray(4);\n        this[0] = x;\n        this[1] = y;\n        this[2] = z;\n        this[3] = w;\n    }\n\n\t/**\n\t *  Checks if `this == v` on an element-by-element basis\n\t *  @param v - The quaternion to check against\n\t *  @return Bool\n\t */\n\tpublic inline function equals(b:Quat):Bool {\n\t\tvar equal:Bool = true;\n\t\tfor(i in 0...4) {\n\t\t\tif(Math.abs(this[i] - b[i]) >= glm.GLM.EPSILON) {\n\t\t\t\tequal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn equal;\n\t}\n\n\t/**\n\t *  Creates a string reprentation of `this`\n\t *  @return String\n\t */\n\tpublic inline function toString():String {\n\t\treturn\n\t\t\t'{${this[0]}, ${this[1]}, ${this[2]}, ${this[3]}}';\n\t}\n\n    /**\n     *  Calculates the square of the magnitude of the quaternion, to save calculation time if the actual magnitude isn't needed\n     *  @return Float\n     */\n    public inline function lengthSquared():Float {\n        return x*x + y*y + z*z + w*w;\n    }\n\n    /**\n     *  Calculates the magnitude of the quaternion\n     *  @return Float\n     */\n    public inline function length():Float {\n        return Math.sqrt(lengthSquared());\n    }\n\n    /**\n     *  Normalizes `q` such that `q.length() == 1`, and stores the result in `dest`\n     *  @param q - \n     *  @param dest - \n     *  @return Quat\n     */\n    public inline static function normalize(q:Quat, dest:Quat):Quat {\n        var length:Float = q.length();\n        var mult:Float = 0;\n        if(length >= glm.GLM.EPSILON) {\n            mult = 1 / length;\n        }\n        return Quat.multiplyScalar(q, mult, dest);\n    }\n\n    /**\n     *  Calculates the dot product of two quaternions\n     *  @param a - \n     *  @param b - \n     *  @return Float\n     */\n    public inline static function dot(a:Quat, b:Quat):Float {\n        return a.x * b.x +\n            a.y * b.y +\n            a.z * b.z +\n            a.w * b.w;\n    }\n\n\t/**\n\t *  Fills `dest` with an identity quat\n\t *  @param dest - \n\t *  @return Quat\n\t */\n\tpublic inline static function identity(dest:Quat):Quat {\n        dest.x = 0;\n        dest.y = 0;\n        dest.z = 0;\n        dest.w = 1;\n        return dest;\n    }\n\n\t/**\n\t *  Copies one quaternion into another\n\t *  @param src - The quaternion to copy from\n\t *  @param dest - The quaternion to copy into\n\t *  @return Quat\n\t */\n\tpublic inline static function copy(src:Quat, dest:Quat):Quat {\n        dest.x = src.x;\n        dest.y = src.y;\n        dest.z = src.z;\n        dest.w = src.w;\n        return dest;\n    }\n\n    /**\n     *  Creates a quaternion from an axis and an angle (in radians).\n     *  @param axis - The axis to rotate about. Must be normalized first!\n     *  @param angle - The angle to rotate by, in radians\n     *  @param dest - Where to store the result\n     *  @return Quat\n     */\n    public inline static function axisAngle(axis:Vec3, angle:Float, dest:Quat):Quat {\n        angle *= 0.5;\n        var s:Float = Math.sin(angle);\n        dest.x = s * axis.x;\n        dest.y = s * axis.y;\n        dest.z = s * axis.z;\n        dest.w = Math.cos(angle);\n        return dest;\n    }\n\n    /**\n     *  Multiplies two quaternions together, both inputs are cached so either can be used as the destination\n     *  @param a - The left-hand side quaternion\n     *  @param b - The right-hand side quaternion\n     *  @param dest - Where to store the result\n     *  @return Quat\n     */\n    public inline static function multiplyQuats(a:Quat, b:Quat, dest:Quat):Quat {\n        var ax:Float = a.x, ay:Float = a.y, az:Float = a.z, aw:Float = a.w;\n        var bx:Float = b.x, by:Float = b.y, bz:Float = b.z, bw:Float = b.w;\n\n        dest.x = ax * bw + aw * bx + ay * bz - az * by;\n        dest.y = ay * bw + aw * by + az * bx - ax * bz;\n        dest.z = az * bw + aw * bz + ax * by - ay * bx;\n        dest.w = aw * bw - ax * bx - ay * by - az * bz;\n\n        return dest;\n    }\n\n    /**\n     *  Shortcut for `multiplyQuats(a, b, new Quat())`\n     *  @param a - The left-hand side quaternion\n     *  @param b - The right-hand side quaternion\n     *  @return Quat\n     */\n    @:op(A * B)\n    public inline static function multiplyQuatsOp(a:Quat, b:Quat):Quat {\n        return multiplyQuats(a, b, new Quat());\n    }\n\n    /**\n     *  Scales `a` by `s`, storing the result in `dest`\n     *  @param a - \n     *  @param s - \n     *  @param dest - \n     *  @return Quat\n     */\n    public inline static function multiplyScalar(a:Quat, s:Float, dest:Quat):Quat {\n        dest.x = a.x * s;\n        dest.y = a.y * s;\n        dest.z = a.z * s;\n        dest.w = a.w * s;\n        return dest;\n    }\n\n    /**\n     *  Shortcut for `multiplyScalar(a, s, new Quat())`\n     *  @param a - \n     *  @param s - \n     *  @return Quat\n     */\n    @:op(A * B)\n    public inline static function multiplyScalarOp(a:Quat, s:Float):Quat {\n        return multiplyScalar(a, s, new Quat());\n    }\n\n    /**\n     *  Linearly interpolates between `a` and `b`. Note: you probably want `slerp`!\n     *  @param a - The value when `t == 0`\n     *  @param b - The value when `t == 1`\n     *  @param t - A value between `0` and `1`, not clamped by the function\n     *  @param dest - The vector to store the result in\n     *  @return Quat\n     */\n    public inline static function lerp(a:Quat, b:Quat, t:Float, dest:Quat):Quat {\n        dest.x = glm.GLM.lerp(a.x, b.x, t);\n        dest.y = glm.GLM.lerp(a.y, b.y, t);\n        dest.z = glm.GLM.lerp(a.z, b.z, t);\n        dest.w = glm.GLM.lerp(a.w, b.w, t);\n        return dest;\n    }\n\n    /**\n     *  Spherical-linear interpolates between `a` and `b`\n     *  @param a - The value when `t == 0`\n     *  @param b - The value when `t == 1`\n     *  @param t - A value between `0` and `1`, not clamped by the function\n     *  @param dest - The vector to store the result in\n     *  @return Quat\n     */\n    public inline static function slerp(a:Quat, b:Quat, t:Float, dest:Quat):Quat {\n        var bx:Float = b.x, by:Float = b.y, bz:Float = b.z, bw:Float = b.w;\n\n        // calculate cosine\n        var cosTheta:Float = dot(a, b);\n\n        // if cosTheta < 0, the interpolation will go the long way around\n        // invert \n        if(cosTheta < 0) {\n            cosTheta = -cosTheta;\n            bx = -bx;\n            by = -by;\n            bz = -bz;\n            bw = -bw;\n        }\n\n        // perform a linear interpolation when cosTheta is\n        // close to 1 to avoid side effect of sin(angle)\n        // becoming a zero denominator\n        if(cosTheta > 1 - glm.GLM.EPSILON) {\n            return lerp(a, b, t, dest);\n        }\n        else {\n            var angle:Float = Math.acos(cosTheta);\n            var sa:Float = 1 / Math.sin(angle);\n            var i:Float = Math.sin((1 - t) * angle);\n            var j:Float = Math.sin(t * angle);\n\n            dest.x = (i * a.x + j * bx) * sa;\n            dest.y = (i * a.y + j * by) * sa;\n            dest.z = (i * a.z + j * bz) * sa;\n            dest.w = (i * a.w + j * bw) * sa;\n            return dest;\n        }\n    }\n\n    /**\n     *  Inverts the quaterion `q`, storing the result in `dest`\n     *  @param q - \n     *  @param dest - \n     *  @return Quat\n     */\n    public inline static function invert(q:Quat, dest:Quat):Quat {\n        var x:Float = q.x, y:Float = q.y, z:Float = q.z, w:Float = q.w;\n        var d:Float = dot(q, q);\n        var oneOverD:Float = if(d < glm.GLM.EPSILON) 0; else 1 / d;\n\n        dest.x = -x * oneOverD;\n        dest.y = -y * oneOverD;\n        dest.z = -z * oneOverD;\n        dest.w =  w * oneOverD;\n\n        return dest;\n    }\n\n    /**\n     *  Calculates the conjugate of `q`, storing the result in `dest`\n     *  @param q - \n     *  @param dest - \n     *  @return Quat\n     */\n    public inline static function conjugate(q:Quat, dest:Quat):Quat {\n        dest.x = -1 * q.x;\n        dest.y = -1 * q.y;\n        dest.z = -1 * q.z;\n        dest.w =      q.w;\n        return dest;\n    }\n\n    /**\n     *  Constructs a quaternion from roll, pitch, and yaw (x, y, and z axes)\n     *  @param x - The angle to rotate around x\n     *  @param y - The angle to rotate around y\n     *  @param z - The angle to rotate around z\n     *  @param dest - Where to store the result\n     *  @return Quat\n     */\n    public inline static function fromEuler(x:Float, y:Float, z:Float, dest:Quat):Quat {\n        var c1:Float = Math.cos(x / 2), c2:Float = Math.cos(y / 2), c3:Float = Math.cos(z / 2);\n        var s1:Float = Math.sin(x / 2), s2:Float = Math.sin(y / 2), s3:Float = Math.sin(z / 2);\n\n        dest.x = s1 * c2 * c3 + c1 * s2 * s3;\n        dest.y = c1 * s2 * c3 - s1 * c2 * s3;\n        dest.z = c1 * c2 * s3 + s1 * s2 * c3;\n        dest.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n        return dest;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.systems;\n\nimport edge.ISystem;\nimport mammoth.components.Transform;\n\nusing glm.Vec3;\nusing glm.Quat;\n\nclass PreTransformSystem implements ISystem {\n    public function update(transform:Transform) {\n        // update the previous values to equal our current ones\n        transform.position.copy(transform.lastPosition);\n        transform.rotation.copy(transform.lastRotation);\n        transform.scale.copy(transform.lastScale);\n    }\n}\n\n","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.systems;\n\nimport edge.ISystem;\nimport edge.View;\nimport mammoth.components.MeshRenderer;\nimport mammoth.components.Transform;\nimport mammoth.components.Camera;\nimport mammoth.components.DirectionalLight;\nimport mammoth.components.PointLight;\nimport mammoth.Mammoth;\nimport mammoth.gl.GL;\nimport mammoth.types.Material;\nimport mammoth.types.Mesh;\nimport mammoth.types.MeshAttribute;\nimport mammoth.gl.UniformLocation;\nimport mammoth.gl.types.TCullMode;\nimport mammoth.gl.types.TUniformData;\n\nclass RenderSystem implements ISystem {\n    var objects:View<{ transform:Transform, renderer:MeshRenderer }>;\n    var directionalLights:View<{ transform:Transform, light:DirectionalLight }>;\n    var pointLights:View<{ transform:Transform, light:PointLight }>;\n\n    private var MVP:Mat4 = Mat4.identity(new Mat4());\n\n    public function update(camera:Camera) {\n        // calculate the viewport\n        var vpX:Int = Std.int(camera.viewportMin.x * Mammoth.width);\n        var vpY:Int = Std.int(camera.viewportMin.y * Mammoth.height);\n        var vpW:Int = Std.int((camera.viewportMax.x - camera.viewportMin.x) * Mammoth.width);\n        var vpH:Int = Std.int((camera.viewportMax.y - camera.viewportMin.y) * Mammoth.height);\n\n        // clear our region of the screen\n        Mammoth.gl.viewport(vpX, vpY, vpW, vpH);\n        Mammoth.gl.scissor(vpX, vpY, vpW, vpH);\n        Mammoth.gl.clearColor(camera.clearColour);\n        Mammoth.gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n\n        // render each object!\n        for(o in objects) {\n            // cache the things we care about\n            var transform:Transform = o.data.transform;\n            var renderer:MeshRenderer = o.data.renderer;\n            var mesh:Mesh = renderer.mesh;\n            var material:Material = renderer.material;\n\n            // calculate the MVP for this object\n            Mat4.multMat(camera.vp, transform.m, MVP);\n\n            // apply the states\n            if(material.cullMode == TCullMode.None)\n                Mammoth.gl.disable(GL.CULL_FACE);\n            else {\n                Mammoth.gl.enable(GL.CULL_FACE);\n                Mammoth.gl.cullFace(cast(material.cullMode));\n            }\n            Mammoth.gl.depthMask(material.depthWrite);\n            if(material.depthTest)\n                Mammoth.gl.enable(GL.DEPTH_TEST);\n            else\n                Mammoth.gl.disable(GL.DEPTH_TEST);\n            Mammoth.gl.depthFunc(cast(material.depthFunction));\n\n            // switch to our material's program\n            Mammoth.gl.useProgram(material.program);\n\n            // set the M, V, P uniforms\n            if(material.hasUniform('MVP')) {\n                Mammoth.gl.uniformMatrix4fv(material.uniformLocation('MVP'), cast(MVP));\n            }\n            if(material.hasUniform('M')) {\n                Mammoth.gl.uniformMatrix4fv(material.uniformLocation('M'), cast(transform.m));\n            }\n            if(material.hasUniform('VP')) {\n                Mammoth.gl.uniformMatrix4fv(material.uniformLocation('VP'), cast(camera.vp));\n            }\n            if(material.hasUniform('V')) {\n                Mammoth.gl.uniformMatrix4fv(material.uniformLocation('V'), cast(camera.v));\n            }\n            if(material.hasUniform('P')) {\n                Mammoth.gl.uniformMatrix4fv(material.uniformLocation('P'), cast(camera.p));\n            }\n        \n            if(material.hasUniform('directionalLights[0].direction')) {\n                var i:Int = 0;\n                for(dl in directionalLights) {\n                    var light:DirectionalLight = dl.data.light;\n                    Mammoth.gl.uniform3f(material.uniformLocation('directionalLights[${i}].direction'), light.direction.x, light.direction.y, light.direction.z);\n                    Mammoth.gl.uniform3f(material.uniformLocation('directionalLights[${i}].colour'), light.colour.r, light.colour.g, light.colour.b);\n                    i++;\n                }\n            }\n            /*if(material.uniforms.exists('pointLights[0].position')) {\n                var i:Int = 0;\n                for(pl in pointLights) {\n                    material.setUniform('pointLights[${i}].position', TUniform.Vec3(pl.data.transform.position));\n                    material.setUniform('pointLights[${i}].colour', TUniform.RGB(pl.data.light.colour));\n                    material.setUniform('pointLights[${i}].distance', TUniform.Float(pl.data.light.distance));\n                    i++;\n                }\n            }*/\n            // TODO: spotlights\n\n            // apply material data\n            for(dataName in renderer.materialData.keys()) {\n                if(!material.hasUniform(dataName)) continue;\n\n                var location:UniformLocation = material.uniformLocation(dataName);\n                var data:TUniformData = renderer.materialData.get(dataName);\n                switch(data) {\n                    case Bool(b): Mammoth.gl.uniform1i(location, b ? 1 : 0);\n                    case Int(i): Mammoth.gl.uniform1i(location, i);\n                    case Float(x): Mammoth.gl.uniform1f(location, x);\n                    case Float2(x, y): Mammoth.gl.uniform2f(location, x, y);\n                    case Float3(x, y, z): Mammoth.gl.uniform3f(location, x, y, z);\n                    case Float4(x, y, z, w): Mammoth.gl.uniform4f(location, x, y, z, w);\n                    case Vector2(v): Mammoth.gl.uniform2f(location, v.x, v.y);\n                    case Vector3(v): Mammoth.gl.uniform3f(location, v.x, v.y, v.z);\n                    case Vector4(v): Mammoth.gl.uniform4f(location, v.x, v.y, v.z, v.w);\n                    case Matrix4(m): Mammoth.gl.uniformMatrix4fv(location, cast(m));\n                    case RGB(c): Mammoth.gl.uniform3f(location, c.r, c.g, c.b);\n                    case RGBA(c): Mammoth.gl.uniform4f(location, c.r, c.g, c.b, c.a);\n                }\n            }\n\n            // set up the attributes\n            Mammoth.gl.bindBuffer(GL.ARRAY_BUFFER, mesh.vertexBuffer);\n            for(materialAttribute in material.attributes) {\n                if(!mesh.hasAttribute(materialAttribute.name))\n                    throw new mammoth.debug.Exception('Can\\t use material ${material.name} with mesh ${mesh.name} as mesh is missing attribute ${materialAttribute.name}!', true);\n                var meshAttribute:MeshAttribute = mesh.getAttribute(materialAttribute.name);\n\n                Mammoth.gl.enableVertexAttribArray(materialAttribute.location);\n                Mammoth.gl.vertexAttribPointer(materialAttribute.location,\n                    switch(meshAttribute.type) {\n                        case Float: 1;\n                        case Vec2: 2;\n                        case Vec3: 3;\n                        case Vec4: 4;\n                    },\n                    GL.FLOAT,\n                    false,\n                    meshAttribute.stride, meshAttribute.offset);\n            }\n\n            // bind the index buffer to the vertices for triangles\n            Mammoth.gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, mesh.indexBuffer);\n\n            // and draw those suckers!\n            Mammoth.gl.drawElements(GL.TRIANGLES, mesh.indexCount, GL.UNSIGNED_SHORT, 0);\n            Mammoth.stats.drawCalls++;\n            Mammoth.stats.triangles += Std.int(mesh.indexCount / 3);\n\n            // disable the attrib arrays!\n            for(materialAttribute in material.attributes) {\n                Mammoth.gl.disableVertexAttribArray(materialAttribute.location);\n            }\n        }\n    }\n}\n","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.types;\n\nimport haxe.ds.StringMap;\nimport mammoth.debug.Exception;\nimport mammoth.gl.AttributeLocation;\nimport mammoth.gl.UniformLocation;\nimport mammoth.gl.GL;\nimport mammoth.gl.Shader;\nimport mammoth.gl.Program;\nimport mammoth.gl.types.TCullMode;\nimport mammoth.gl.types.TDepthFunction;\nimport mammoth.gl.types.TShader;\nimport mammoth.gl.types.TVertexAttribute;\nimport mammoth.gl.types.TShaderUniform;\nimport mammoth.types.MaterialAttribute;\nimport mammoth.types.ShaderUniform;\n\nclass Material {\n    public var program(default, null):Program;\n    private var vertexShaderSource:String;\n    public var vertexShader(default, null):Shader;\n    private var fragmentShaderSource:String;\n    public var fragmentShader(default, null):Shader;\n\n    public var name(default, null):String;\n    public var attributes(default, null):StringMap<MaterialAttribute>;\n    public var uniforms(default, null):StringMap<ShaderUniform>;\n\n    public var cullMode:TCullMode = TCullMode.Back;\n    public var depthWrite:Bool = true;\n    public var depthTest:Bool = true;\n    public var depthFunction:TDepthFunction = TDepthFunction.LessOrEqual;\n\n    public function new(name:String) {\n        this.name = name;\n        attributes = new StringMap<MaterialAttribute>();\n        uniforms = new StringMap<ShaderUniform>();\n    }\n\n    public function toString():String {\n        var h:String = 'Material: ${name}\\n';\n        h += 'Attributes:\\n';\n        for(attribute in attributes) {\n            h += '  ${attribute.name} (${attribute.type}) at ${attribute.location}\\n';\n        }\n        h += 'Uniforms:\\n';\n        for(uniform in uniforms) {\n            h += '  ${uniform.name} (${uniform.type})\\n';\n        }\n        return h;\n    }\n\n    public function setShaderSource(source:String, type:TShader):Material {\n        switch(type) {\n            case TShader.Vertex: vertexShaderSource = source;\n            case TShader.Fragment: fragmentShaderSource = source;\n        }\n        return this;\n    }\n\n    private function compileShader(source:String, type:TShader):Shader {\n        var shader:Shader = Mammoth.gl.createShader(cast(type));\n        Mammoth.gl.shaderSource(shader, source);\n        Mammoth.gl.compileShader(shader);\n\t\tif(!Mammoth.gl.getShaderParameter(shader, GL.COMPILE_STATUS)) {\n\t\t\tvar info:String = Mammoth.gl.getShaderInfoLog(shader);\n\t\t\tvar typeStr:String = type == TShader.Vertex ? 'Vertex' : 'Fragment';\n\t\t\tthrow new Exception(info, true, 'Compile${typeStr}Shader');\n\t\t}\n\t\treturn shader;\n    }\n\n    public function compile():Material {\n        if(vertexShaderSource == null || fragmentShaderSource == null)\n            throw new Exception('Can\\'t compile material ${name}, shaders are missing!', true);\n        \n        vertexShader = compileShader(vertexShaderSource, TShader.Vertex);\n        fragmentShader = compileShader(fragmentShaderSource, TShader.Fragment);\n\n        program = Mammoth.gl.createProgram();\n        Mammoth.gl.attachShader(program, vertexShader);\n        Mammoth.gl.attachShader(program, fragmentShader);\n\n        Mammoth.gl.linkProgram(program);\n\t\tif(!Mammoth.gl.getProgramParameter(program, GL.LINK_STATUS)) {\n\t\t\tvar info:String = Mammoth.gl.getProgramInfoLog(program);\n\t\t\tthrow new Exception(info, true, 'LinkProgram');\n\t\t}\n\n        return this;\n    }\n\n    public function registerAttribute(name:String, type:TVertexAttribute):Material {\n        var attribute:MaterialAttribute = new MaterialAttribute(name, type);\n\n        // to locate the attribute, we need to get GL to use the program first\n        Mammoth.gl.useProgram(program);\n        attribute.location = Mammoth.gl.getAttribLocation(program, name);\n\n        attributes.set(name, attribute);\n        return this;\n    }\n\n    public function registerUniform(name:String, type:TShaderUniform):Material {\n        var uniform:ShaderUniform = new ShaderUniform(name, type);\n\n        Mammoth.gl.useProgram(program);\n        uniform.location = Mammoth.gl.getUniformLocation(program, name);\n\n        uniforms.set(name, uniform);\n        return this;\n    }\n\n    public inline function hasAttribute(name:String):Bool {\n        return attributes.exists(name);\n    }\n\n    public inline function attributeLocation(name:String):AttributeLocation {\n        return attributes.get(name).location;\n    }\n\n    public inline function hasUniform(name:String):Bool {\n        return uniforms.exists(name);\n    }\n\n    public inline function uniformLocation(name:String):UniformLocation {\n        return uniforms.get(name).location;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.types;\n\nimport mammoth.gl.AttributeLocation;\nimport mammoth.gl.types.TVertexAttribute;\n\n@:allow(mammoth.types.Material)\nclass MaterialAttribute {\n    public var name(default, null):String;\n    public var type(default, null):TVertexAttribute;\n\n    public var location(default, null):AttributeLocation;\n\n    public function new(name:String, type:TVertexAttribute) {\n        this.name = name;\n        this.type = type;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.types;\n\nimport mammoth.gl.GL;\nimport mammoth.gl.Buffer;\nimport mammoth.gl.types.TBufferUsage;\nimport mammoth.platform.Float32Array;\nimport mammoth.platform.Int16Array;\nimport mammoth.gl.types.TVertexAttribute;\n\nclass Mesh {\n    public var vertexBuffer(default, null):Buffer;\n    public var indexBuffer(default, null):Buffer;\n    public var indexCount(default, null):Int;\n\n    public var name(default, null):String;\n    public var attributes(default, null):Array<MeshAttribute>;\n\n    public function new(name:String) {\n        this.name = name;\n\n        vertexBuffer = Mammoth.gl.createBuffer();\n        indexBuffer = Mammoth.gl.createBuffer();\n        indexCount = 0;\n\n        attributes = new Array<MeshAttribute>();\n    }\n\n    public function toString():String {\n        var h:String = 'Mesh: ${name}\\n';\n        h += 'Triangles: ${indexCount / 3}\\n';\n        h += 'Attributes:\\n';\n        for(attribute in attributes) {\n            h += '  ${attribute.name} (${attribute.type}) ${attribute.stride}-${attribute.offset}\\n';\n        }\n        return h;\n    }\n\n    public function registerAttribute(name:String, type:TVertexAttribute, ?order:Int):Mesh {\n        var attribute:MeshAttribute = new MeshAttribute(name, type);\n        if(order == null) attributes.push(attribute);\n        else attributes.insert(order, attribute);\n        return this;\n    }\n\n    public function setVertexData(data:Array<Float>, usage:TBufferUsage = TBufferUsage.Static):Mesh {\n        Mammoth.gl.bindBuffer(GL.ARRAY_BUFFER, vertexBuffer);\n        Mammoth.gl.bufferData(GL.ARRAY_BUFFER, new Float32Array(data), cast(usage));\n        Mammoth.gl.bindBuffer(GL.ARRAY_BUFFER, null);\n        return this;\n    }\n\n    public function setIndexData(data:Array<Int>, usage:TBufferUsage = TBufferUsage.Static):Mesh {\n        Mammoth.gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, indexBuffer);\n        Mammoth.gl.bufferData(GL.ELEMENT_ARRAY_BUFFER, new Int16Array(data), cast(usage));\n        Mammoth.gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, null);\n        indexCount = data.length;\n        return this;\n    }\n\n    public function compile():Void {\n        var offset:Int = 0;\n        for(attribute in attributes) {\n            attribute.offset = offset;\n            offset += switch(attribute.type) {\n                case Float: 4;\n                case Vec2: 8;\n                case Vec3: 12;\n                case Vec4: 16;\n                case _: throw new mammoth.debug.Exception('Unhandled attribute type ${attribute.type}!', true);\n            }\n        }\n\n        for(attribute in attributes) {\n            attribute.stride = offset;\n        }\n    }\n\n    public function hasAttribute(name:String):Bool {\n        for(attribute in attributes) {\n            if(attribute.name == name) return true;\n        }\n        return false;\n    }\n\n    public function getAttribute(name:String):MeshAttribute {\n        for(attribute in attributes) {\n            if(attribute.name == name) return attribute;\n        }\n        return null;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.types;\n\nimport mammoth.gl.types.TVertexAttribute;\n\n@:allow(mammoth.types.Mesh)\nclass MeshAttribute {\n    public var name(default, null):String;\n    public var type(default, null):TVertexAttribute;\n\n    public var stride(default, null):Int;\n    public var offset(default, null):Int;\n\n    public function new(name:String, type:TVertexAttribute) {\n        this.name = name;\n        this.type = type;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.types;\n\nimport mammoth.gl.UniformLocation;\nimport mammoth.gl.types.TShaderUniform;\n\nclass ShaderUniform {\n    public var name(default, null):String;\n    public var type(default, null):TShaderUniform;\n\n    @:allow(mammoth.types.Material)\n    public var location(default, null):UniformLocation;\n\n    public function new(name:String, type:TShaderUniform) {\n        this.name = name;\n        this.type = type;\n    }\n}","/**\n  This is a primitive asynchronous class, used as a base class for Promise and\n  Signal.\n **/\n\n\npackage promhx.base;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.Thenable;\n\ntypedef AsyncLink<T> = {\n    async : AsyncBase<Dynamic>,\n    linkf : T->Void\n}\n\n\nclass AsyncBase<T>{\n#if debug\n    // add ids to the async instances so they are easier to track\n    static var id_ctr  = 0;\n    var id          : Int;\n    public var constructorPos :haxe.PosInfos;\n    public var parentConstructorPos :Array<haxe.PosInfos> = [];\n    // var constructorPos :haxe.PosInfos;\n#end\n    var _val        : T;\n    var _resolved   : Bool;\n    var _fulfilled  : Bool;\n    var _pending    : Bool;\n    var _update     : Array<AsyncLink<T>>;\n    var _error      : Array<Dynamic->Void>;\n    var _errored    : Bool;\n    var _errorMap   : Dynamic->T;\n    var _errorVal   : Dynamic;\n    var _errorPending : Bool;\n\n    public function new(?d:Deferred<T> #if debug ,?pos:haxe.PosInfos #end) {\n#if debug\n        id = id_ctr +=1;\n        constructorPos = pos;\n#end\n        _resolved   = false;\n        _pending = false;\n        _errorPending = false;\n        _fulfilled  = false;\n        _update     = [];\n        _error      = [];\n        _errored    = false;\n\n        if (d != null){\n            link(d,this, function(x) return x);\n        }\n\n    }\n\n    /**\n      Catch error, effectively halting the current update chain.\n      This will prevent downstream async objects from receiving\n      the error message.\n     **/\n    public function catchError(f : Dynamic->Void) {\n        _error.push(f);\n        return this;\n    }\n\n    /**\n      Map errors back to the expected type, and continue as normal.\n     **/\n    public function errorThen( f : Dynamic -> T){\n        _errorMap = f;\n        return this;\n    }\n\n    /**\n      Utility function to determine if a Promise value has been resolved.\n     **/\n    public inline function isResolved() : Bool\n        return _resolved;\n\n    /**\n      Utility function to determine if a Promise value is in an error state.\n     **/\n    public inline function isErrored() : Bool\n        return _errored;\n\n    /**\n      Utility function to determine if a Promise has handled the error.\n     **/\n    public inline function isErrorHandled() : Bool\n        return _error.length > 0;\n\n    /**\n      Utility function to determine if a Promise error is pending.\n     **/\n    public inline function isErrorPending() : Bool\n        return _errorPending;\n\n    /**\n      Utility function to determine if a Promise value has been rejected.\n     **/\n    public inline function isFulfilled(): Bool\n        return _fulfilled;\n\n    /**\n      Utility function to determine if a Promise value is pending operations\n      on the next loop.\n     **/\n    public inline function isPending() : Bool\n        return _pending;\n\n\n    function handleResolve(val:T) : Void {\n        _resolve(val);\n    }\n    /**\n      Resolves the given value for processing on any waiting functions.\n     **/\n    function _resolve(val : T) : Void {\n\n        // this async is pending an update on the next loop, move the\n        // resolve to the loop after that.\n        if (_pending){\n            EventLoop.enqueue(_resolve.bind(val));\n        } else {\n\n            // point of no return, this async has now been resolved at least once.\n            _resolved = true;\n\n            // we are now in the act of fulfilling the async... which\n            // involves waiting for the next enqueued loop\n            _pending = true;\n\n            // the loop handler, which may not even be used\n            EventLoop.enqueue(function(){\n                _val = val; // save the value\n                for (up in _update){\n#if PromhxExposeErrors\n                    up.linkf(val);\n#else\n                    try up.linkf(val)\n                catch (e:Dynamic) up.async.handleError(e);\n#end\n                }\n                _fulfilled = true; // we're in a fulfilled state\n                _pending = false; // we're done fulfilling for this resolve\n            });\n        }\n\n    }\n\n    /**\n      Handle errors, can be overridden\n     **/\n    function handleError(error : Dynamic) : Void {\n        _handleError(error);\n    }\n\n    function _handleError(error : Dynamic) : Void {\n        var update_errors = function(e:Dynamic){\n            if (_error.length > 0) for (ef in _error) ef(e);\n            else if (_update.length > 0) for (up in _update) up.async.handleError(e);\n            else {\n#if debug\n                var stacks = parentConstructorPos.concat([]);\n                stacks.push(constructorPos);\n                //Deduplicate\n                var set = new Map<String, Bool>();\n                var i = 0;\n                while (i < stacks.length) {\n                    var key = stacks[i].className + stacks[i].methodName + stacks[i].lineNumber;\n                    if (set.exists(key)) {\n                        stacks.splice(i, 1);\n                    } else {\n                        set.set(key, true);\n                        i++;\n                    }\n                }\n                var stackString = 'Promise Call Stack:\\n\\t' + stacks.map(function(s) {\n                    return '${s.fileName}:${s.lineNumber} ${s.className}.${s.methodName}()';\n                }).join('\\n\\t');\n                // haxe.Json.stringify(stacks, null, '\\t');\n                trace(stackString);\n#end\n#if (js && nodejs)\n                // Node sometimes doesn't produce helpful stack information on thrown errors.\n                trace('Call Stack: ' + haxe.CallStack.toString(haxe.CallStack.callStack()));\n#end\n                throw e;\n            }\n            this._errorPending = false;\n        }\n        if (!_errorPending){\n            _errorPending = true;\n            _errored = true;\n            _errorVal = error;\n\n            EventLoop.enqueue(function(){\n                if (_errorMap != null){\n#if PromhxExposeErrors\n                    this._resolve(_errorMap(error));\n                    _resolve(_errorMap(error));\n#else\n                    try this._resolve(_errorMap(error))\n                        catch (e : Dynamic) update_errors(e);\n#end\n                } else {\n                    update_errors(error);\n                }\n            });\n        }\n    }\n\n    /**\n      This function returns a new AsyncBase.  When this instance resolves,\n      it will resolve the new AsyncBase with the function callback argument.\n     **/\n    public function then<A>(f : T->A #if debug ,?pos:haxe.PosInfos #end) : AsyncBase<A> {\n        var ret = new AsyncBase<A>(null #if debug ,pos #end);\n        link(this, ret, f);\n        return ret;\n    }\n\n    /**\n      Remove an Async that is updated from this Async.  This action is\n      performed on the next event loop.\n     **/\n    public function unlink( to : AsyncBase<Dynamic>) {\n        EventLoop.enqueue(function(){\n            _update =  _update.filter(function(x) return x.async != to);\n        });\n    }\n\n    /**\n      Determine if an Async is updated from this Async.\n     **/\n    public function isLinked( to : AsyncBase<Dynamic>) : Bool {\n        var updated = false;\n        for (u in _update) if (u.async == to) return true;\n        return updated;\n    }\n\n\n    /**\n      This is the base \"link\" method for wiring up the \"current\" async to\n      the \"next\" one via the transform defined by the f argument.\n     **/\n    inline public static function link<A,B>\n        (current : AsyncBase<A>, next: AsyncBase<B>, f : A->B) : Void\n    {\n#if debug\n        next.parentConstructorPos = current.parentConstructorPos.concat([]);\n        next.parentConstructorPos.push(current.constructorPos);\n#end\n        // the function wrapper for the callback, which will resolve the return\n        // if current is not resolved, or will resolve next loop, push to\n        // update queues.\n        current._update.push({\n            async : next,\n            linkf : function(x){\n                next.handleResolve(f(x));\n            }\n        });\n        immediateLinkUpdate(current, next, f);\n    }\n\n    static function immediateLinkUpdate<A,B>\n        (current : AsyncBase<A>, next : AsyncBase<B>, f : A->B) : Void\n    {\n        if (current.isErrored()  // is there an error?\n                && !current.isErrorPending()  // if the error is pending, we can rely on current to update this async on the next loop.\n                && !current.isErrorHandled() ) // if the error is handled by current, we'll ignore it.\n                    next.handleError(current._errorVal);\n\n        // then the value\n        if (current.isResolved() && !current.isPending()){\n            // we can go ahead and resolve this.\n#if PromhxExposeErrors\n            next.handleResolve(f(current._val));\n#else\n            try next.handleResolve(f(current._val))\n            catch (e:Dynamic) next.handleError(e);\n#end\n        }\n\n    }\n\n    inline public static function linkAll<T>\n        (all : Iterable<AsyncBase<T>>, next: AsyncBase<Array<T>>) : Void\n    {\n        // a helper callback function.  This will be called for each Stream in\n        // the iterable argument.  The \"arr\" argument will be all of the Streams\n        // *except* the one currently resolving.  If there's only one Stream\n        // in the iterable, it will always resolve.\n        var cthen = function(arr:Array<AsyncBase<T>>, current:AsyncBase<T>,  v){\n            if (arr.length == 0 || AsyncBase.allFulfilled(arr)){\n                var vals = [for (a in all) a == current ? v : a._val];\n                next.handleResolve(vals);\n            }\n            return null;\n        };\n        for (a in all){\n            a._update.push({\n                async : next,\n                linkf: cthen.bind([for (a2 in all) if (a2 != a) a2], a, _)\n            });\n        }\n\n        if (AsyncBase.allFulfilled(all)) {\n            next.handleResolve([for (a in all) a._val]);\n        }\n    }\n\n    /**\n      Similar to the link function, except the [f] function must return an\n      AsyncBase instance.\n     **/\n    inline static public function pipeLink<A,B>\n        ( current : AsyncBase<A>, ret : AsyncBase<B>, f : A->AsyncBase<B> ) : Void\n    {\n        var linked = false;\n        var linkf = function(x){ // updates go to pipe function.\n                if (!linked){ // but only once\n                    linked = true; // the piped async doesn't actually respond to updates from current\n                    var pipe_ret = f(x); // it just needs to be created\n                    pipe_ret._update.push({  // and to be linked to ret\n                        async : ret, // errors go to ret\n                        linkf : ret.handleResolve // updates go directly to ret\n                    });\n                    immediateLinkUpdate(pipe_ret, ret, function(x) return x );\n                }\n            }\n\n        current._update.push({\n            async : ret, // errors go to ret\n            linkf : linkf\n        });\n\n        if (current.isResolved() && !current.isPending()){\n#if PromhxExposeErrors\n            linkf(current._val);\n#else\n            try linkf(current._val)\n            catch (e:Dynamic) ret.handleError(e);\n#end\n        }\n    }\n\n    /**\n      Utility function to determine if all Promise values are set.\n     **/\n    public static function allResolved\n        (as : Iterable<AsyncBase<Dynamic>>) : Bool\n    {\n        for (a in as) {\n            if (!a.isResolved()) return false;\n        }\n        return true;\n    }\n\n    /**\n      Utility function to determine if all Promise values are resolved and\n      are currently fulfilled (not in the process of fulfilling).\n     **/\n    static function allFulfilled\n        (as : Iterable<AsyncBase<Dynamic>>) : Bool\n    {\n        for (a in as) {\n            if (!a.isFulfilled()) return false;\n        }\n        return true;\n    }\n\n}\n","package promhx;\nimport promhx.base.AsyncBase;\n\n@:expose\nclass Deferred<T> extends AsyncBase<T> {\n\n    public function new() super();\n\n    /**\n      The public write interface\n     **/\n    public function resolve(val:T) handleResolve(val);\n\n    inline public function throwError(e:Dynamic) handleError(e);\n\n    /**\n      Returns a new promise based on the current deferred instance\n     **/\n    public function promise(){\n        return new Promise(this);\n    }\n\n    /**\n      Returns a new stream based on the current deferred instance\n     **/\n    public function stream(){\n        return new Stream(this);\n    }\n\n    /**\n      Returns a stream based on the current deferred instance\n     **/\n    public function publicStream(){\n        return new PublicStream(this);\n    }\n}\n","package promhx;\n\n#if macro\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\nimport haxe.macro.Context;\n#end\nimport promhx.base.EventLoop;\nimport promhx.base.AsyncBase;\nimport promhx.error.PromiseError;\n\n@:expose\nclass Promise<T> extends AsyncBase<T>{\n    var _rejected   : Bool;\n\n    public function new(?d:Deferred<T> #if debug, ?pos:haxe.PosInfos #end){\n        super(d #if debug, pos #end);\n        _rejected = false;\n    }\n\n\n\n    /**\n      Macro method that binds the promise arguments to a single function\n      callback that is triggered when all promises are resolved.\n      Note: You may call this function on as many promise arguments as you\n      like.\n     **/\n    macro public static function when<T>( args : Array<ExprOf<Promise<Dynamic>>>) : Expr {\n\n        // a default position\n        var pos = Context.currentPos();\n\n        //the macro arguments translated to an array expression.\n        var eargs = {expr:EArrayDecl(args), pos:pos};\n\n        // An array of the resolved promise values\n        var epargs = [for (i in 0...args.length) macro arr[$v{i}]._val];\n\n        // the returned function that actually does the runtime work.\n        return macro @:privateAccess {\n            // a function that accepts a variable argument function\n            var varargf = function(f){\n                // we wait on all of the promises with the iterable-based \"whenAll\"\n                // this will resolve an array, so we use pipe to ignore it, and set\n                // up a new promise for return.\n                // this new promise resolves via a macro-defined function expression\n                // on \"f\" that provides arity and types for the resolved promise values.\n                var ret = new promhx.Promise();\n                var arr : Array<promhx.Promise<Dynamic>> = $eargs;\n                var p = new Promise<Array<Dynamic>>();\n                promhx.base.AsyncBase.linkAll(arr, p);\n                p._update.push({\n                    async : ret,\n                    linkf : function(x) ret.handleResolve(f($a{epargs}))\n                });\n                return ret;\n            };\n\n            // return an anonymous object with the function definition for \"then\"\n            { then : varargf };\n        }\n    }\n\n    /**\n      Utility function to determine if a Promise value has been rejected.\n     **/\n    public inline function isRejected(): Bool {\n        return _rejected;\n    }\n\n    /**\n      Rejects the promise, throwing an error.\n     **/\n    public function reject(e : Dynamic): Void {\n        _rejected = true;\n        handleError(e);\n    }\n\n    /**\n      Transforms an iterable of promises into a single promise which resolves\n      to an array of values.\n     **/\n    public static function whenAll<T>(itb : Iterable<Promise<T>> #if debug ,?pos:haxe.PosInfos #end) : Promise<Array<T>> {\n        var ret : Promise<Array<T>> = new Promise(null #if debug ,pos #end);\n        AsyncBase.linkAll(itb, ret);\n        return ret;\n    }\n\n    /**\n      Resolves the given value for processing on any waiting functions.\n     **/\n    override function handleResolve(val : T): Void {\n        if (_resolved) {\n            var msg = \"Promise has already been resolved\";\n            throw(AlreadyResolved(msg));\n        }\n        _resolve(val);\n    }\n\n    /**\n      add a wait function directly to the Promise instance.\n     **/\n    override public function then<A>(f : T->A #if debug ,?pos:haxe.PosInfos #end): Promise<A> {\n        var ret  = new Promise<A>(null #if debug ,pos #end);\n        AsyncBase.link(this, ret, f);\n        return ret;\n    }\n\n    override public function unlink( to : AsyncBase<Dynamic>) {\n        EventLoop.enqueue(function(){\n            if (!isFulfilled()) {\n                var msg = \"Downstream Promise is not fullfilled\";\n                handleError(DownstreamNotFullfilled(msg));\n            }\n            else{\n                _update =  _update.filter(function(x) return x.async != to);\n            }\n        });\n    }\n\n    override function handleError(error : Dynamic) : Void {\n       _rejected = true;\n       _handleError(error);\n    }\n\n    public function pipe<A>(f : T->Promise<A> #if debug ,?pos:haxe.PosInfos #end) : Promise<A> {\n        var ret = new Promise<A>(null #if debug ,pos #end);\n        AsyncBase.pipeLink(this, ret, f);\n        return ret;\n    }\n\n    /**\n      Pipes an error back into a normal type.\n      **/\n    public function errorPipe( f: Dynamic-> Promise<T>){\n        var ret = new Promise<T>();\n        catchError(function(e){\n            var piped = f(e);\n            piped.then(ret._resolve);\n        });\n        then(ret._resolve);\n        return ret;\n    }\n\n    /**\n      Converts any value to a resolved Promise\n     **/\n    public static function promise<T>(_val : T #if debug ,?pos:haxe.PosInfos #end): Promise<T> {\n        var ret = new Promise<T>(#if debug null,pos #end);\n        ret.handleResolve(_val);\n        return ret;\n    }\n}\n\n","package promhx.base;\n\nprivate typedef Queue = #if java java.vm.AtomicList #else List #end <Void->Void>;\n\nclass EventLoop {\n    static var queue : Queue = new Queue();\n\n    // public static var nextLoop(default, set) : (Void->Void)-> Void;\n    public static var nextLoop : (Void->Void)-> Void;\n\n#if (js && !nodejs && !noEmbedJs && !noEmbedSetImmediate)\n    static function __init__() untyped {\n#if !nodejs\n        // we need to use global as an alternate since setImmediate expects this == window\n        var global = window;\n#end\n        haxe.macro.Compiler.includeFile(\"lib/setImmediate/setImmediate.js\");\n    }\n#end\n\n    public static inline function enqueue(eqf:Void->Void)  {\n        queue.add(eqf);\n        continueOnNextLoop();\n    }\n    static function set_nextLoop(f : (Void->Void)->Void) : (Void->Void)->Void{\n        if (nextLoop != null) throw \"nextLoop has already been set\";\n        else nextLoop = f;\n        return nextLoop;\n    }\n\n    /**\n      Retrieve the current length of the queue.\n     **/\n    public static inline function queueEmpty() {\n        return #if java queue.peekLast() == null #else queue.isEmpty() #end;\n    }\n\n    /**\n      Attempt to finish the remaining loops in the queue.  Returns true\n      if all loops are finished.  If [max_iterations] pass, then exit and\n      return false.\n     **/\n    public static function finish(max_iterations = 1000){\n        var fn = null;\n        while (max_iterations-- > 0 && (fn = queue.pop()) != null){\n            fn();\n        }\n        return queueEmpty();\n    }\n\n    /**\n      Clear the existing event loop queue.\n     **/\n    public static function clear(){\n        queue = new Queue();\n    }\n\n    static function f(){\n        var fn = queue.pop();\n        if (fn != null) fn();\n        if (!queueEmpty()) continueOnNextLoop();\n    }\n\n    static function continueOnNextLoop(){\n        if (nextLoop != null) nextLoop(f);\n        else {\n\n#if flash\n            haxe.Timer.delay(f,0);\n#elseif (js && (noEmbedJs || noEmbedSetImmediate) && !nodejs)\n            // fallback to setTimeout\n            untyped __js__(\"(typeof setImmediate === 'function' ? setImmediate : setTimeout)\")(f);\n#elseif js\n            // use polyfill or native node\n            untyped __js__(\"setImmediate\")(f);\n#else\n            f();\n#end\n        }\n    }\n}\n","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage systems;\n\nimport mammoth.Mammoth;\nimport edge.ISystem;\nimport mammoth.components.Transform;\nimport components.Spin;\n\nclass SpinSystem implements ISystem {\n    private var axis:Vec3 = new Vec3(0, 0, 1);\n\n    public function update(transform:Transform, spin:Spin) {\n        spin.angle += spin.speed * Mammoth.timing.dt;\n        Quat.axisAngle(axis, spin.angle, transform.rotation);\n    }\n}","package tusk;\n\nimport tusk.text.Font;\n\nclass Draw {\n    public var screenWidth(default, set):Float = 1;\n    private function set_screenWidth(w:Float):Float {\n        if(w != screenWidth) vpDirty = true;\n        return screenWidth = w;\n    }\n\n    public var screenHeight(default, set):Float = 1;\n    private function set_screenHeight(h:Float):Float {\n        if(h != screenHeight) vpDirty = true;\n        return screenHeight = h;\n    }\n\n    private var vpDirty:Bool = true;\n    public var vpMatrix(get, null):Mat4 = Mat4.identity(new Mat4());\n    private function get_vpMatrix():Mat4 {\n        if(vpDirty) {\n            GLM.orthographic(0, screenWidth, screenHeight, 0, 0, 1, vpMatrix);\n            vpDirty = false;\n        }\n        return vpMatrix;\n    }\n\n    public var buffer(default, null):FloatArray = new FloatArray(8 * 6 * 32);\n    public var numVertices(default, null):Int = 0;\n\n    public var font:Font;\n\n    public function new() {\n        font = Font.fromFontSrc(Tusk.fontSrc);\n    }\n\n    public function newFrame():Void {\n        numVertices = 0;\n    }\n\n    private function addVertex(x:Float, y:Float, u:Float, v:Float, colour:Vec4):Void {\n        var i:Int = numVertices * 8;\n        buffer[i + 0] = x;\n        buffer[i + 1] = y;\n        buffer[i + 2] = u;\n        buffer[i + 3] = v;\n        buffer[i + 4] = colour.r;\n        buffer[i + 5] = colour.g;\n        buffer[i + 6] = colour.b;\n        buffer[i + 7] = colour.a;\n        numVertices++;\n\n        if((numVertices * 8) >= buffer.length) {\n            // resize the buffer\n            var newBuffer:FloatArray = new FloatArray(buffer.length + (8 * 6 * 32));\n            for(i in 0...buffer.length)\n                newBuffer[i] = buffer[i];\n            buffer = newBuffer;\n        }\n    }\n\n    public function text(x:Float, y:Float, text:String, ?colour:Vec4):Void {\n        if(colour == null) colour = TuskConfig.text_Colour;\n        font.print(x, y + font.ascent, text, function(_x:Float, _y:Float, _u:Float, _v:Float):Void {\n            addVertex(_x, _y, _u, _v, colour);\n        });\n    }\n\n    public function window(x:Float, y:Float, w:Float, h:Float, title:String):Void {\n        // draw the body\n        addVertex(x + 0, y + TuskConfig.window_headerHeight, 1, 1, TuskConfig.window_bodyColour);\n        addVertex(x + w, y + TuskConfig.window_headerHeight, 1, 1, TuskConfig.window_bodyColour);\n        addVertex(x + 0, y + h, 1, 1, TuskConfig.window_bodyColour);\n\n        addVertex(x + 0, y + h, 1, 1, TuskConfig.window_bodyColour);\n        addVertex(x + w, y + TuskConfig.window_headerHeight, 1, 1, TuskConfig.window_bodyColour);\n        addVertex(x + w, y + h, 1, 1, TuskConfig.window_bodyColour);\n        \n        // draw the header\n        addVertex(x + 0, y + 0, 1, 1, TuskConfig.window_headerColour);\n        addVertex(x + w, y + 0, 1, 1, TuskConfig.window_headerColour);\n        addVertex(x + 0, y + TuskConfig.window_headerHeight, 1, 1, TuskConfig.window_headerColour);\n\n        addVertex(x + 0, y + TuskConfig.window_headerHeight, 1, 1, TuskConfig.window_headerColour);\n        addVertex(x + w, y + 0, 1, 1, TuskConfig.window_headerColour);\n        addVertex(x + w, y + TuskConfig.window_headerHeight, 1, 1, TuskConfig.window_headerColour);\n\n        // draw the title over the header\n        text(\n            Math.ffloor(x + ((w - font.textWidth(title)) * 0.5)),\n            Math.ffloor(y + (TuskConfig.window_headerHeight - font.lineHeight) * 0.5),\n            title, TuskConfig.window_headerTextColour);\n    }\n\n    public function button(x:Float, y:Float, w:Float, h:Float, label:String, state:InputState):Void {\n        var buttonColour:Vec4 = switch(state) {\n            case InputState.Normal: TuskConfig.button_normalColour;\n            case InputState.Hovered: TuskConfig.button_hoveredColour;\n            case InputState.Pressed: TuskConfig.button_pressedColour;\n            case InputState.Disabled: TuskConfig.button_disabledColour;\n        }\n\n        // draw the body\n        addVertex(x + 0, y + 0, 1, 1, buttonColour);\n        addVertex(x + w, y + 0, 1, 1, buttonColour);\n        addVertex(x + 0, y + h, 1, 1, buttonColour);\n\n        addVertex(x + 0, y + h, 1, 1, buttonColour);\n        addVertex(x + w, y + 0, 1, 1, buttonColour);\n        addVertex(x + w, y + h, 1, 1, buttonColour);\n\n        // draw the label\n        text(Math.ffloor(x + ((w - font.textWidth(label)) * 0.5)), Math.ffloor(y + (h - font.lineHeight) * 0.5), label);\n    }\n}","package tusk.text;\n\nimport haxe.ds.IntMap;\nimport haxe.Json;\n\nclass Font {\n    public var glyphs:IntMap<Glyph> = new IntMap<Glyph>();\n\n    public var base(default, null):Float;\n    public var lineHeight(default, null):Float;\n    public var spaceWidth(default, null):Float;\n    public var ascent(default, null):Float;\n    public var descent(default, null):Float;\n\n    private var unknownGlyph:Glyph;\n\n    public static function fromFontSrc(src:String):Font {\n        return new Font(Json.parse(src));\n    }\n\n    public function new(bmFont:BMFont) {\n        base = bmFont.common.base;\n        lineHeight = bmFont.common.lineHeight;\n        descent = lineHeight - base;\n        ascent = 0;\n\n        var imSize:Vec2 = new Vec2(bmFont.common.scaleW, bmFont.common.scaleH);\n        for(char in bmFont.chars) {\n            var g:Glyph = new Glyph(char, imSize);\n            glyphs.set(char.id, g);\n\n            // find the maximum ascent\n            var a:Float = base - g.size.y;\n            if(a > ascent) {\n                ascent = a;\n            }\n        }\n\n        unknownGlyph = glyphs.get('?'.charCodeAt(0));\n        spaceWidth = glyphs.get(' '.charCodeAt(0)).xAdvance;\n    }\n\n    public function textWidth(text:String):Float {\n        var width:Float = 0, maxWidth:Float = 0;\n\n        for(i in 0...text.length) {\n            var idx:Int = text.charCodeAt(i);\n            if(idx == null) continue;\n\n            // deal with special characters\n            width += switch(idx) {\n                case 32: { // ' '\n                    spaceWidth;\n                }\n\n                case 10: { // '\\n'\n                    if(width > maxWidth)\n                        maxWidth = width;\n                    -1 * width;\n                }\n\n                case 13: { // '\\r'\n                    if(width > maxWidth)\n                        maxWidth = width;\n                    -1 * width;\n                }\n\n                case 9: { // '\\t'\n                    4 * spaceWidth;\n                }\n\n                case 0x1B: { // escape\n                    0;\n                }\n\n                case _: {\n                    var g:Glyph = glyphs.get(idx);\n                    if(g == null) g = unknownGlyph;\n                    g.xAdvance;\n                }\n            }\n        }\n\n        if(width > maxWidth)\n            maxWidth = width;\n\n        return maxWidth;\n    }\n\n    public function print(x:Float, y:Float, text:String, addVertex:AddVertexFunc):Void {\n        var _x:Float = x;\n        var _y:Float = y;\n\n        var i:Int = 0;\n        var colour:Vec4 = null;\n        while(i < text.length) {\n            var idx:Int = text.charCodeAt(i);\n            if(idx == null) continue;\n\n            // deal with special characters\n            if(idx == ' '.charCodeAt(0)) {\n                _x += spaceWidth;\n                continue;\n            }\n            else if(idx == '\\n'.charCodeAt(0)) {\n                _x = x;\n                _y += lineHeight;\n                continue;\n            }\n            else if(idx == '\\r'.charCodeAt(0)) {\n                _x = x;\n                continue;\n            }\n            else if(idx == '\\t'.charCodeAt(0)) {\n                _x += (spaceWidth * 4);\n                continue;\n            }\n            else if(idx == 0x1B) {\n                if(i + 1 >= text.length) return;\n                colour = switch(text.charCodeAt(i + 1)) {\n                    case 0x72: colour = new Vec4(1, 0, 0, 1); // 'r'\n                    case 0x67: colour = new Vec4(0, 1, 0, 1); // 'g'\n                    case 0x62: colour = new Vec4(0, 0, 1, 1); // 'b'\n                    case 0x63: colour = new Vec4(0, 1, 1, 1); // 'c'\n                    case 0x79: colour = new Vec4(1, 1, 0, 1); // 'y'\n                    case 0x6d: colour = new Vec4(1, 0, 1, 1); // 'm'\n                    case 0x6b: colour = new Vec4(0, 0, 0, 1); // 'k'\n                    case _: null;\n                };\n                i += 2;\n                continue;\n            }\n\n            // draw a glyph\n            var g:Glyph = glyphs.get(idx);\n            if(g == null) g = unknownGlyph;\n\n            var x0:Float = _x + g.offset.x;\n            var x1:Float = x0 + g.size.x;\n            var y0:Float = _y + g.offset.y - base;\n            var y1:Float = y0 + g.size.y;\n\n            addVertex(x0, y0, g.uvMin.x, g.uvMin.y);\n            addVertex(x1, y0, g.uvMax.x, g.uvMin.y);\n            addVertex(x0, y1, g.uvMin.x, g.uvMax.y);\n\n            addVertex(x0, y1, g.uvMin.x, g.uvMax.y);\n            addVertex(x1, y0, g.uvMax.x, g.uvMin.y);\n            addVertex(x1, y1, g.uvMax.x, g.uvMax.y);\n\n            _x += g.xAdvance;\n            i++;\n        }\n    }\n}","package tusk.text;\n\nclass Glyph {\n    public var uvMin:Vec2;\n    public var uvMax:Vec2;\n\n    public var xAdvance:Float;\n    public var size:Vec2;\n    public var offset:Vec2;\n\n    public function new(char:BMFont.Char, imSize:Vec2) {\n        uvMin = new Vec2(char.x / imSize.x, char.y / imSize.y);\n        uvMax = new Vec2(uvMin.x + (char.width / imSize.x), uvMin.y + (char.height / imSize.y));\n\n        xAdvance = char.xadvance;\n        size = new Vec2(char.width, char.height);\n        offset = new Vec2(char.xoffset, char.yoffset);\n    }\n}","package tusk;\n\nimport haxe.ds.IntMap;\nimport tusk.macros.FileContents;\n\n#if js\ntypedef FloatArray = js.html.Float32Array;\n#else\ntypedef FloatArray = haxe.io.Float32Array;\n#end\n\nclass Tusk {\n    public static var vertexShaderSrc(default, null):String = FileContents.contents('tusk/assets/vertex.glsl');\n    public static var fragmentShaderSrc(default, null):String = FileContents.contents('tusk/assets/fragment.glsl');\n    public static var fontTextureSrc(default, null):String = 'data:image/png;base64,' + FileContents.base64contents('tusk/assets/coderscrux.png');\n    public static var fontSrc(default, null):String = FileContents.contents('tusk/assets/coderscrux.json');\n\n    public static var draw(default, null):Draw = new Draw();\n    public static var controls(default, null):IntMap<Control> = new IntMap<Control>();\n\n    private function new() {}\n\n    private static var mousePos:Vec2 = new Vec2();\n    private static var mousePressed:Bool = false;\n    private static var mouseDown:Bool = false;\n    private static var mouseReleased:Bool = false;\n\n    private static var nextPos:Vec2 = new Vec2();\n    private static var currentWidth:Float = 0;\n\n    public static function updateInput(mx:Float, my:Float, mouseDown:Bool):Void {\n        mousePos.set(mx, my);\n\n        Tusk.mousePressed = mouseDown && !Tusk.mouseDown;\n        Tusk.mouseReleased = !mouseDown && Tusk.mouseDown;\n        Tusk.mouseDown = mouseDown;\n    }\n\n    private inline static function getControl(uuid:Int):Control {\n        // get or create the control\n        if(!controls.exists(uuid))\n            controls.set(uuid, new Control());\n        return controls.get(uuid);\n    }\n\n    private static function updateInputState(control:Control, x:Float, y:Float, w:Float, h:Float):Void {\n        // skip all this logic if we're disabled\n        if(control.state == InputState.Disabled) return;\n        \n        // detect hovers\n        var mousedOver:Bool = mousePos.x >= x && mousePos.x <= x + w && mousePos.y >= y && mousePos.y <= y + h;\n        if(mousedOver) {\n            if(control.state == InputState.Normal) {\n                control.state = InputState.Hovered;\n            }\n            if(Tusk.mousePressed) {\n                control.state = InputState.Pressed;\n            }\n        }\n        else if(control.state == InputState.Hovered) {\n            control.state = InputState.Normal;\n        }\n\n        // detect clicks\n        control.clicked = false;\n        if(control.state == InputState.Pressed && Tusk.mouseReleased) {\n            control.clicked = true;\n\n            if(mousedOver) {\n                control.state = InputState.Hovered;\n            }\n            else {\n                control.state = InputState.Normal;\n            }\n        }\n    }\n\n    public static function window(uuid:Int, x:Float, y:Float, w:Float, h:Float, title:String):Void {\n        // TODO\n        var control:Control = getControl(uuid);\n\n        nextPos.set(x + 2, y + 2 + TuskConfig.window_headerHeight);\n        currentWidth = w - 4;\n        draw.window(x, y, w, h, title);\n    }\n\n    public static function label(text:String):Void {\n        draw.text(nextPos.x, nextPos.y, text);\n        nextPos.y += draw.font.lineHeight + 4;\n    }\n\n    public static function button(uuid:Int, label:String):Bool {\n        var control:Control = getControl(uuid);\n        updateInputState(control, nextPos.x, nextPos.y, currentWidth, draw.font.lineHeight + 4);\n        draw.button(nextPos.x, nextPos.y, currentWidth, draw.font.lineHeight + 4, label, control.state);\n        nextPos.y += draw.font.lineHeight + 4 + 4;\n        return control.clicked;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage glm;\n\nusing glm.Mat4;\nusing glm.Vec4;\n\n#if js\ntypedef FloatArray = js.html.Float32Array;\n#else\ntypedef FloatArray = haxe.io.Float32Array;\n#end\n\nclass GLM {\n    /**\n     *  Minimum absolute value difference of floats before they are considered equal\n     */\n    public static var EPSILON:Float = 0.0000001;\n\n    /**\n     *  Utility for linearly interpolating between two values\n     *  @param a - The value when `t == 0`\n     *  @param b - The value when `t == 1`\n     *  @param t - A value between `0` and `1`, not clamped by the function\n     *  @return Float\n     */\n    public inline static function lerp(a:Float, b:Float, t:Float):Float {\n        return a + t * (b - a);\n    }\n\n    /**\n     *  Constructs a 3D translation matrix\n     *  @param translation - How far to move in each of the directions\n     *  @param dest - Where the result will be stored\n     *  @return Mat4\n     */\n    public inline static function translate(translation:Vec3, dest:Mat4):Mat4 {\n        dest.identity();\n        dest.r0c3 = translation.x;\n        dest.r1c3 = translation.y;\n        dest.r2c3 = translation.z;\n        return dest;\n    }\n\n    /**\n     *  Constructs a 3D rotation matrix\n     *  @param rotation - The quaternion to use as rotation\n     *  @param dest - Where the result will be stored\n     *  @return Mat4\n     */\n    public inline static function rotate(rotation:Quat, dest:Mat4):Mat4 {\n        var x2:Float = rotation.x+rotation.x, y2:Float = rotation.y+rotation.y, z2:Float = rotation.z+rotation.z;\n\t\tvar xx:Float = rotation.x * x2, xy:Float = rotation.x * y2, xz:Float = rotation.x * z2;\n\t\tvar yy:Float = rotation.y * y2, yz:Float = rotation.y * z2, zz:Float = rotation.z * z2;\n\t\tvar wx:Float = rotation.w * x2, wy:Float = rotation.w * y2, wz:Float = rotation.w * z2;\n\n        dest.r0c0 = 1 - (yy + zz);\n        dest.r0c1 = xy - wz;\n        dest.r0c2 = xz + wy;\n        dest.r0c3 = 0;\n\n        dest.r1c0 = xy + wz;\n        dest.r1c1 = 1 - (xx + zz);\n        dest.r1c2 = yz - wx;\n        dest.r1c3 = 0;\n        \n        dest.r2c0 = xz - wy;\n        dest.r2c1 = yz + wx;\n        dest.r2c2 = 1 - (xx + yy);\n        dest.r2c3 = 0;\n\n        dest.r3c0 = 0;\n        dest.r3c1 = 0;\n        dest.r3c2 = 0;\n        dest.r3c3 = 1;\n        return dest;\n    }\n\n    /**\n     *  Constructs a 3D scale matrix\n     *  @param amount - How much to scale by in each of the three directions\n     *  @param dest - Where the result will be stored\n     *  @return Mat4\n     */\n    public inline static function scale(amount:Vec3, dest:Mat4):Mat4 {\n        dest.identity();\n        dest.r0c0 = amount.x;\n        dest.r1c1 = amount.y;\n        dest.r2c2 = amount.z;\n        return dest;\n    }\n\n    /**\n     *  Constructs a complete transformation matrix from translation, rotation, and scale components.\n     *  It should be a fair bit faster than constructing each on their own and multiplying together.\n     *  @param translation - The translation vector\n     *  @param rotation - The rotation quaternion\n     *  @param scale - The scale vector\n     *  @param dest - Where to store the result\n     *  @return Mat4\n     */\n    public inline static function transform(translation:Vec3, rotation:Quat, scale:Vec3, dest:Mat4):Mat4 {\n        var x2:Float = rotation.x + rotation.x;\n        var y2:Float = rotation.y + rotation.y;\n        var z2:Float = rotation.z + rotation.z;\n\n        var xx:Float = rotation.x * x2;\n        var xy:Float = rotation.x * y2;\n        var xz:Float = rotation.x * z2;\n        var yy:Float = rotation.y * y2;\n        var yz:Float = rotation.y * z2;\n        var zz:Float = rotation.z * z2;\n        var wx:Float = rotation.w * x2;\n        var wy:Float = rotation.w * y2;\n        var wz:Float = rotation.w * z2;\n\n        dest.r0c0 = (1 - (yy + zz)) * scale.x;\n        dest.r1c0 = (xy + wz) * scale.x;\n        dest.r2c0 = (xz - wy) * scale.x;\n        dest.r3c0 = 0;\n        dest.r0c1 = (xy - wz) * scale.y;\n        dest.r1c1 = (1 - (xx + zz)) * scale.y;\n        dest.r2c1 = (yz + wx) * scale.y;\n        dest.r3c1 = 0;\n        dest.r0c2 = (xz + wy) * scale.z;\n        dest.r1c2 = (yz - wx) * scale.z;\n        dest.r2c2 = (1 - (xx + yy)) * scale.z;\n        dest.r3c2 = 0;\n        dest.r0c3 = translation.x;\n        dest.r1c3 = translation.y;\n        dest.r2c3 = translation.z;\n        dest.r3c3 = 1;\n        return dest;\n    }\n\n    /**\n     *  Constructs a lookat matrix to position a view matrix at `eye`, looking at `centre`, with `up` orienting the view\n     *  @param eye - Where the viewer is located\n     *  @param centre - Where the viewer is looking at\n     *  @param up - A vector pointing `up` for the view\n     *  @param dest - Where to store the result\n     *  @return Mat4\n     */\n    public static function lookAt(eye:Vec3, centre:Vec3, up:Vec3, dest:Mat4):Mat4 {\n        var x0:Float, x1:Float, x2:Float, y0:Float, y1:Float, y2:Float, z0:Float, z1:Float, z2:Float;\n        var len:Float;\n\n        if (Math.abs(eye.x - centre.x) < EPSILON &&\n            Math.abs(eye.y - centre.y) < EPSILON &&\n            Math.abs(eye.z - centre.z) < EPSILON) {\n            dest.identity();\n            return dest;\n        }\n\n        z0 = eye.x - centre.x;\n        z1 = eye.y - centre.y;\n        z2 = eye.z - centre.z;\n\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        x0 = up.y * z2 - up.z * z1;\n        x1 = up.z * z0 - up.x * z2;\n        x2 = up.x * z1 - up.y * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (len <= EPSILON) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        }\n        else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (len <= EPSILON) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        }\n        else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest.r0c0 = x0;\n        dest.r1c0 = y0;\n        dest.r2c0 = z0;\n        dest.r3c0 = 0;\n\n        dest.r0c1 = x1;\n        dest.r1c1 = y1;\n        dest.r2c1 = z1;\n        dest.r3c1 = 0;\n\n        dest.r0c2 = x2;\n        dest.r1c2 = y2;\n        dest.r2c2 = z2;\n        dest.r3c2 = 0;\n\n        dest.r0c3 = -(x0 * eye.x + x1 * eye.y + x2 * eye.z);\n        dest.r1c3 = -(y0 * eye.x + y1 * eye.y + y2 * eye.z);\n        dest.r2c3 = -(z0 * eye.x + z1 * eye.y + z2 * eye.z);\n        dest.r3c3 = 1;\n        return dest;\n    }\n\n    /**\n     *  Constructs a perspective projection matrix\n     *  Taken from https://github.com/toji/gl-matrix/blob/master/src/gl-matrix/mat4.js#L1788\n     *  @param fovy - The vertical field of view in radians\n     *  @param aspectRatio - The aspect ratio of the view\n     *  @param near - The near clipping plane\n     *  @param far - The far clipping plane\n     *  @param dest - Where to store the result\n     *  @return Mat4\n     */\n    public inline static function perspective(fovy:Float, aspectRatio:Float, near:Float, far:Float, dest:Mat4):Mat4 {\n        var f:Float = 1 / Math.tan(fovy / 2);\n        var nf:Float = 1 / (near - far);\n\n        dest.r0c0 = f / aspectRatio;\n        dest.r1c0 = 0;\n        dest.r2c0 = 0;\n        dest.r3c0 = 0;\n\n        dest.r0c1 = 0;\n        dest.r1c1 = f;\n        dest.r2c1 = 0;\n        dest.r3c1 = 0;\n        \n        dest.r0c2 = 0;\n        dest.r1c2 = 0;\n        dest.r2c2 = (far + near) * nf;\n        dest.r3c2 = -1;\n\n        dest.r0c3 = 0;\n        dest.r1c3 = 0;\n        dest.r2c3 = (2 * far * near) * nf;\n        dest.r3c3 = 0;\n        return dest;\n    }\n\n    /**\n     *  Constructs an orthographic projection matrix\n     *  @param left - \n     *  @param right - \n     *  @param bottom - \n     *  @param top - \n     *  @param near - \n     *  @param far - \n     *  @param dest - Where to store the result\n     *  @return Mat4\n     */\n    public inline static function orthographic(left:Float, right:Float, bottom:Float, top:Float, near:Float=-1, far:Float=1, dest:Mat4):Mat4 {\n        var rl:Float = 1 / (right - left);\n        var tb:Float = 1 / (top - bottom);\n        var fn:Float = 1 / (far - near);\n\n        dest.r0c0 = 2 * rl;\n        dest.r0c1 = 0;\n        dest.r0c2 = 0;\n        dest.r0c3 = -1 * (left + right) * rl;\n\n        dest.r1c0 = 0;\n        dest.r1c1 = 2 * tb;\n        dest.r1c2 = 0;\n        dest.r1c3 = -1 * (top + bottom) * tb;\n\n        dest.r2c0 = 0;\n        dest.r2c1 = 0;\n        dest.r2c2 = -2 * fn;\n        dest.r2c3 = -1 * (far + near) * fn;\n\n        dest.r3c0 = 0;\n        dest.r3c1 = 0;\n        dest.r3c2 = 0;\n        dest.r3c3 = 1;\n        return dest;\n    }\n\n    /**\n     *  Constructs an orthographic projection matrix\n     *  Taken from: https://github.com/toji/gl-matrix/blob/master/src/gl-matrix/mat4.js#L1755\n     *  @param left - \n     *  @param right - \n     *  @param bottom - \n     *  @param top - \n     *  @param near - \n     *  @param far - \n     *  @param dest - Where to store the result\n     *  @return Mat4\n     */\n    public inline static function frustum(left:Float, right:Float, bottom:Float, top:Float, near:Float=-1, far:Float=1, dest:Mat4):Mat4 {\n        var rl:Float = 1 / (right - left);\n        var tb:Float = 1 / (top - bottom);\n        var nf:Float = 1 / (near - far);\n\n        dest.r0c0 = (near * 2) * rl;\n        dest.r1c0 = 0;\n        dest.r2c0 = 0;\n        dest.r3c0 = 0;\n\n        dest.r0c1 = 0;\n        dest.r1c1 = (near * 2) * tb;\n        dest.r2c1 = 0;\n        dest.r3c1 = 0;\n        \n        dest.r0c2 = (right + left) * tb;\n        dest.r1c2 = (top + bottom) * tb;\n        dest.r2c2 = (far + near) * nf;\n        dest.r3c2 = -1;\n\n        dest.r0c3 = 0;\n        dest.r1c3 = 0;\n        dest.r2c3 = (far * near * 2) * nf;\n        dest.r3c3 = 0;\n        return dest;\n    }\n}","/*\n * Copyright (c) 2017 Kenton Hamaluik\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage mammoth.defaults;\n\nimport mammoth.types.Colour;\n\nclass Colours {\n    public static var Black:Colour = new Colour(0, 0, 0, 1);\n    public static var White:Colour = new Colour(1, 1, 1, 1);\n}","package tusk.macros;\n\nimport haxe.macro.Expr;\nimport haxe.io.Path;\nimport haxe.io.Bytes;\nimport haxe.crypto.Base64;\n\nclass FileContents {\n    macro public static function contents(path:String):ExprOf<String> {\n        var parts:Array<String> = path.split('/');\n        parts.insert(0, 'src');\n        #if sys\n        parts.insert(0, Sys.getCwd());\n        #end\n        var assetFilename:String = Path.join(parts);\n\n        var source:String = sys.io.File.getContent(assetFilename);\n        return macro $v{source};\n    }\n\n    macro public static function base64contents(path:String):ExprOf<String> {\n        var parts:Array<String> = path.split('/');\n        parts.insert(0, 'src');\n        #if sys\n        parts.insert(0, Sys.getCwd());\n        #end\n        var assetFilename:String = Path.join(parts);\n\n        var source:Bytes = sys.io.File.getBytes(assetFilename);\n        var srcString:String = Base64.encode(source);\n        return macro $v{srcString};\n    }\n}","package tusk;\n\nclass TuskConfig {\n    public static var text_Colour:Vec4 = new Vec4(1, 1, 1, 1);\n\n    public static var window_headerHeight:Float = 16;\n    public static var window_headerColour:Vec4 = new Vec4(0, 0, 0, 0.75);\n    public static var window_headerTextColour:Vec4 = new Vec4(1, 1, 1, 1);\n    public static var window_bodyColour:Vec4 = new Vec4(0, 0, 0, 0.5);\n\n    public static var button_normalColour:Vec4 = new Vec4(0.5, 0.5, 0.5, 0.9);\n    public static var button_hoveredColour:Vec4 = new Vec4(0.75, 0.75, 0.75, 1);\n    public static var button_pressedColour:Vec4 = new Vec4(1, 1, 1, 1);\n    public static var button_disabledColour:Vec4 = new Vec4(0.25, 0.25, 0.25, 0.9);\n}"],
"names":[],
"mappings":"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"
}